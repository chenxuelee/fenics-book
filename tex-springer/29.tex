\bgroup

\setcounter{chapter}{28}
\setcounter{chpnum}{28}

\fenicschapter{An adaptive finite element solver for fluid--structure interaction problems}
              {An adaptive finite element solver\\ for fluid--structure interaction problems}
              {An adaptive finite element solver for fluid--structure interaction problems}
              {Kristoffer Selim}
              {selim}

\index{incompressible Navier--Stokes equations}
\index{fluid--structure interaction}

%% My commands
\newcommand{\subdt}{\textrm{d}_t}
\newcommand{\divv}{\textrm{div}\;}
\newcommand{\Divv}{\textrm{Div}\;}
\newcommand{\uF}{u_{_{F}}}
\newcommand{\dotuF}{\dot{u}_{_{F}}}
\newcommand{\pF}{p_{_{F}}}
\newcommand{\rhoF}{\rho_{_{F}}}
\newcommand{\sigmaF}{\sigma_{_{F}}}
\newcommand{\sigmaFup}{\sigma_{_{F}}(u_{_{F}}, p_{_{F}})}
\newcommand{\sigmaS}{\sigma_{_{S}}}
\newcommand{\bff}{b_{_{F}}}
\newcommand{\graduF}{\textrm{grad}\;u_{_{F}}}
\newcommand{\US}{U_{_{S}}}
\newcommand{\uS}{u_{_{S}}}
\newcommand{\GradUS}{\textrm{Grad}\;U_{_{S}}}
\newcommand{\ddotUS}{\ddot{U}_{_{S}}}
\newcommand{\ddotuS}{\ddot{u}_{_{S}}}
\newcommand{\PS}{P_{_{S}}}
\newcommand{\rhoS}{\rho_{_{S}}}
\newcommand{\SigmaS}{\Sigma_{_{S}}}
\newcommand{\SigmaSU}{\Sigma_{_{S}}(U_{_{S}})}
\newcommand{\BS}{B_{_{S}}}
\newcommand{\M}{\mathcal{M}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\oF}{\omega_{_{F}}}
\newcommand{\oS}{\omega_{_{S}}}
\newcommand{\OS}{\Omega_{_{S}}}
\newcommand{\OF}{\Omega_{_{F}}}
\newcommand{\PhiS}{\Phi_{_{S}}}
\newcommand{\PhiM}{\Phi_{_{M}}}
\newcommand{\FS}{F_{_{S}}}
\newcommand{\UM}{U_{_{M}}}
\newcommand{\SigmaM}{\Sigma_{_{M}}}
\newcommand{\GradUM}{\textrm{Grad}\;U_{_{M}}}
\newcommand{\UF}{U_{_{F}}}
\newcommand{\PF}{P_{_{F}}}
\newcommand{\AFF}{A_{_{FF}}}
\newcommand{\AFS}{A_{_{FS}}}
\newcommand{\AFM}{A_{_{FM}}}
\newcommand{\ASS}{A_{_{SS}}}
\newcommand{\ASF}{A_{_{SF}}}
\newcommand{\ASM}{A_{_{SM}}}
\newcommand{\AMM}{A_{_{MM}}}
\newcommand{\AMF}{A_{_{MF}}}
\newcommand{\AMS}{A_{_{MS}}}

Fluid--structure interaction (FSI) occurs when a fluid interacts with
a solid structure, exerting a traction force that causes deformation
of the structure and, thus, alters the flow of the fluid itself.  The
FSI problem is a fully coupled multiphysics problem, whether the
problem is solved in a partitioned manner or by a monolithic
approach. In many cases we are only interested in one
physical output quantity of the fully coupled system, e.g., the
displacement of the structure. In order to compute this particular
physical output of interest with a high level of accuracy, a goal
oriented adaptive finite element method can be used.

This chapter gives a short introduction to goal oriented adaptive
finite element approximation for FSI problems and demonstrates how to
solve them using FEniCS. We start by formulating an FSI problem and
show how it is implemented in FEniCS. We then define and explain the
corresponding adaptive algorithm for the FSI problem. For a more
comprehensive discussion on goal oriented adaptive finite element
methods for FSI problems, we refer
to~\citet{SelimLogg2011a,Dunne2007,Dunne2006,
GratschBathe2006,BengzonLarson2010,ZeeBrummelenBorst2008a, Van2009}.


\section{Fluid--structure interaction}
\label{selim:sec:fsi}

Fluids and solids obey the fundamental conservation laws that hold
for any adiabatic continuum body: the balance of linear momentum and
the conservation of mass.  These fundamental conservation laws can be
expressed in local form as\vspace*{-2pt}
\begin{align}
\label{selim:eq:momentum}
\subdt(\rho u) - \divv \sigma &= b,\\
\label{selim:eq:continuity}
\subdt(\rho) &= 0,\vspace*{-2pt}
\end{align}
where~\eqref{selim:eq:momentum} is the balance of linear momentum
and~\eqref{selim:eq:continuity} is the conservation of mass.  Here,
$\subdt(\cdot)$ denotes a material time derivative, $\rho$ the density,
$u$ the velocity, $\sigma$ the stress, and $b$ represents a given body
force per unit volume. In an FSI problem, the different physical
quantities of the fluid and the structure, denoted with subscripts
$F$ and $S$ respectively, transfer traction forces and exchange data
at a given common fluid--structure boundary.  Traction forces are
given by normal stresses and at the common fluid--structure boundary,
the following equilibrium equation holds:\vspace*{-2pt}
\begin{equation}
\label{selim:eq:traction}
\sigma_{_{F}}\cdot n_{_{F}} =  - \sigma_{_{S}}\cdot n_{_{S}},\vspace*{-2pt}
\end{equation}
where $n_{_{F}}$ and $n_{_{S}}$ denote the outward normals on the
fluid--structure boundary, viewed from the fluid and structure
domains, respectively. Hence, $n_{_{F}} = - n_{_{S}}$. \pagebreak In addition to~\eqref{selim:eq:traction}, we also require kinematic
continuity at the common fluid--structure boundary; that is, the
velocity of the fluid and the solid are equal at the common
fluid--structure boundary. How a continuum
responds to stress and in particular to shear stress, distinguishes a
fluid continuum from a solid continuum. A fluid cannot withstand shear
forces; it will continue to deform as long as the stress is
applied. Solids, on the other hand, respond with an angular strain and
the strain continues until the displacement is sufficient to generate
internal forces that balance the imposed stress. To capture this, the
constitutive laws modeling fluids and solids relate the stress tensor
to different physical measures. Moreover, these measures are from a
practical point of view naturally posed in different frameworks, the
so-called Lagrangian framework and the Eulerian framework.


\vspace*{-2pt}\enlargethispage*{12pt}
\subsection{Lagrangian framework and structural mechanics}
\index{Lagrangian framework}

An essential kinematic measure in structural mechanics is the
displacement field which is naturally posed in the Lagrangian
framework.  In the Lagrangian framework, the motion of a body is
related to a fixed material point $x_0$ and the position of
such a point at time $t$ is given by the sufficiently smooth bijective
map $\phi$ that maps the point $x_0$ at time $t$ to the point $x(t)=
\phi(x_0,t)$. The \emph{structure displacement} is defined as
$\uS(x_0,t) = \phi(x_0, t) - x_0$ with the corresponding non-singular
Jacobi matrix $f = \textrm{grad}\;\phi$ and Jacobi determinant $j =
\textrm{det}\; f$. Thus, the material time derivative of a function $y$
in the Lagrangian framework is given by $\subdt(y) = \dot{y}$.

Constitutive laws for hyperelastic materials express the stress tensor
$\sigma_{_{S}}$ (referred to as the first Piola--Kirchhoff stress)
as the Frech\'{e}t derivative of a given energy functional $\psi$.
The energy functional can depend on different kinds of kinematic measures,
and if $\psi$ is dependent on the so-called Green--Lagrange tensor $e=
\tfrac{1}{2}(f^{\top}f -I)$, the corresponding first Piola--Kirchhoff
tensor is given by $\sigma_{_{S}} = f\cdot\frac{\partial \psi(e)}{\partial
e}$. In this chapter, we focus on the compressible St.~Venant--Kirchhoff
model where the stress is described by the energy functional $\psi(e) =
\mu_{_{S}}\textrm{tr}(e^2) + \frac{\lambda_{_{S}}}{2}(\textrm{tr}(e))^2$,
where $(\mu_{_{S}},\lambda_{_{S}})$ are given positive Lam\'{e}
constants. Hence, the conservation laws for a ~St. Venant--Kirchhoff
material in the Lagrangian framework is given by\vspace*{-3pt}
\begin{align}
\label{selim:eq:SVKmom}
\rhoS \ddotuS - \divv\sigmaS(\uS) &= b_{_{S}},\\
\label{selim:eq:SVKcon}
\dot{\rho}_{_{S}}&=0,\vspace*{-3pt}
\end{align}
with the corresponding stress tensor $\sigmaS(\uS) = f\cdot(2\mu_{_{S}}e
+ \lambda_{_{S}} \textrm{tr}(e)I)$.  Note that we usually omit the mass
conservation equation~\eqref{selim:eq:SVKcon} since it is automatically
satisfied for compressible materials in the Lagrangian framework.  For a
more in depth analysis of hyperelastic materials and structural mechanics
in general, see \citet{Gurtin1981,Holzapfel2000}.

\vspace*{-2pt}
\subsection{Eulerian framework and fluid mechanics}
\label{selim:sec:fluid}\index{Eulerian framework}

In fluid mechanics, the primary variables for describing the fluid
motion are the \emph{fluid velocity} $\uF$ and the \emph{fluid pressure}
$\pF$. These variables are naturally posed in the Eulerian framework
where the motion of a body is related to a fixed spatial point $x$ and the
motion of the body is defined as $\uF(x,t) = \uF(\phi(x_0,t),t)$. Thus,
the material time derivative of a function $y$ in the Eulerian framework
is given by $\subdt(y) = \dot{y} + \textrm{grad}\;y\cdot\uF$.

The most common constitutive law for fluids is the Newtonian fluid.
For Newtonian fluids, the stress tensor $\sigmaF$ (referred to as the
Cauchy stress) is given by $\sigmaFup = 2\mu_{_{F}}\varepsilon (\uF) -
\pF I$, where $\mu_{_{F}}$ denotes the dynamic viscosity and
$\varepsilon(\cdot)$ the symmetric gradient. In this chapter, we
assume that the fluid is an incompressible Newtonian fluid. The fluid
is then described by the incompressible Navier--Stokes
equations:\vspace*{-3pt}
\begin{align}
\label{selim:eq:NSmom}
\rhoF(\dot{u}_{_{F}} + \textrm{grad}\;\uF\cdot\uF)- \divv
\sigmaFup &= b_{_{F}},\\
\label{selim:eq:NScon}
\divv \uF &= 0.
\end{align}
For a more in depth analysis of constitutive laws
for fluids and for fluid mechanics in general,
see~\citet{Batchelor1967,Panton1984}.

\begin{figure}[!b]
\centering
\includegraphics{0001335362/272415_1_en_29_fig1_print.eps}
\caption{The mapping $\Phi(X,t$) maps a reference point $X\in\Omega$
    to the current point $x\in\omega(t)$. The deformation gradient of
    the reference domain $\Omega$ is given by $\textrm{Grad}\:\Phi =
    F$, and the volume change of $\Omega$ is thus $J = \textrm{det}(F)$.}
\label{selim:fig:mapping}\vspace*{-6pt}
\end{figure}


\section{FSI and the ALE computational framework}
\label{selim:sec:ale}
\index{ALE}

To combine the Lagrangian and the Eulerian frameworks
in a computational setting, the fluid traction force from
problem~\eqref{selim:eq:NSmom}--\eqref{selim:eq:NScon} is transferred to
the structure problem~\eqref{selim:eq:SVKmom}--\eqref{selim:eq:SVKcon}
via the Piola map: $(j\;\sigma_{_{F}}\cdot f^{-\top})\cdot n_{_{F}} = -
\sigma_{_{S}}\cdot n_{_{S}}$ at the common fluid--structure boundary.
The deformation of the structure, given by the structure solution
in the material domain, needs to be tracked in the spatial fluid
domain and consequently, the mesh in the spatial fluid domain has
to be updated. A~dynamically deforming mesh without any additional
smoothing algorithm will result in a mesh of poor quality. To treat
this shortcoming, an additional mesh equation is posed in the fluid
domain to enhance the mesh quality. Combining the Lagrangian and the
Eulerian frameworks with an additional mesh smoothing algorithm is
commonly referred to as the Arbitrary Lagrangian--Eulerian (ALE) method
\citep{DoneaGiulianiHalleux1982,DoneaHuertaPonthotEtAl2004}. In this
method, both the Lagrangian approach, in which the mesh moves with the
structure, and the Eulerian approach, in which the mesh represents a
fixed reference frame for the fluid, are used. In order to incorporate
the mesh equation in the FSI problem, an arbitrary reference frame for
the fluid domain is introduced which is independent of the Lagrangian
description and the Eulerian description. This arbitrary reference domain
is typically the initial undeformed computational domain.

Let $\Omega$ be a fixed open domain in $\mathbb{R}^d$ which represents
the \emph{reference} (undeformed) computational domain, for
$d=2,3$. Moreover, let $\Omega$ be partitioned into two disjoint open
subsets $\OF$ and $\OS$ such that
$\bar{\Omega}_{_{F}}\cup\bar{\Omega}_{_{S}} = \Omega$ and
$\OF\cap\OS=\emptyset$. Further, let $\omega(t)\in\mathbb{R}^d$ denote
the \emph{current} (deformed) computational domain which is similarly
partitioned into two disjoint subsets $\oF(t)$ and $\oS(t)$ such that
$\bar{\omega}_{_{F}}\cup\bar{\omega}_{_{S}} = \omega$ and
$\oF(t)\cap\oS(t)=\emptyset$, for all time $t\in[0,T]$. The common
boundary between the structure and fluid domains is denoted by
$\Gamma_{FS}$ and $\gamma_{FS}(t)$ respectively. In general, to
distinguish between variables and operators associated with the
reference and current domains, we use upper case and lower case
letters respectively. Thus, $\Divv\SigmaS(\US(X,t))$ is the divergence
of the structure stress defined on the reference structure domain
$\OS$, and $\graduF(x,t)$ is the current gradient of the fluid
velocity defined in the current fluid domain $\oF(t)$.

In order to map between the reference domain and the current domain,
we introduce the sufficiently smooth bijective map $\Phi(\cdot,
t):\Omega\mapsto \omega(t)$.  For any fixed time $t\in[0,T]$, $\Phi$
maps a reference point $X\in\Omega$ to the corresponding current point
$x\in\omega(t)$; that is, $X \mapsto x = \Phi(X,t)$, see
Figure~\ref{selim:fig:mapping}.

Since we allow the fluid and structure portions of the domain to
deform independently (only enforcing that these deformations are
identical on the common boundary), the map is split up as follows:\vspace*{2pt}
\begin{equation}
\label{selim:eq:ALEmapI}
\Phi(X,t) =
\left\{
\begin{array}{ccc}
\PhiS(X, t), \quad \foralls X\in\OS,\; t\in[0,T],\\
\PhiM(X, t), \quad \foralls X\in\OF,\; t\in[0,T].
\end{array}
\right.
\end{equation}
Here, the structure map and the (fluid) mesh map $(\PhiS, \PhiM)$ are
defined as
\begin{align}
\label{selim:eq:ALEmapII}
\PhiS(X, t) &= X + \US(X,t),\\
\PhiM(X, t) &= X + \UM(X,t),
\end{align}
where $(\US, \UM)$ are the solutions to the structure problem and the
arbitrarily chosen mesh problem.  There are several
possible ways to formulate and solve the mesh problem to obtain
$\UM$ \citep{HermanssonHansbo2003, LopezNigroStorti2008}.  In the
following, we have adopted a time dependent mesh problem related to a
linearly elastic description of the fluid domain in which the stress
tensor is given by $\SigmaM(\UM)\equiv \mu_{{_M}}(\GradUM +
\GradUM^{\top})+ \lambda_{_{M}}\textrm{tr}(\GradUM)I$ for some given
positive constants $(\mu_{{_M}},\lambda_{_{M}})$.

To summarize, we identify the three subproblems that together define
the fully coupled FSI \nobreak problem:
\begin{itemize}
  \item the fluid problem $(f)$ solved in the current fluid domain
  $\oF(t)$;

  \item the structure problem $(S)$ solved in the reference structure
  domain $\OS$;

  \item the mesh problem $(M)$ solved in the reference fluid domain $\OF$.
\end{itemize}
The corresponding set of equations for the triplet
$(f),(S),(M)$ is given by:
\begin{align}
  \label{selim:eq:FSIsystem-f-mom}
  &(f):&\quad
  \rhoF(\dotuF + \graduF\cdot\uF) - \divv\sigmaF(\uF,\pF) &= \bff
  \quad&&\textrm{in}\;\oF(t),\\[2.5pt]
  \label{selim:eq:FSIsystem-f-con}
  &&\divv\uF &= 0
  \quad&&\textrm{in}\;\oF(t),\\[2.5pt]
  \label{selim:eq:FSIsystem-S}
  &(S):&\quad
  \rhoS \ddotUS - \Divv \SigmaS(\US) &= \BS
  \quad&&\textrm{in}\;\OS\times(0,T],\\[2.5pt]
  \label{selim:eq:FSIsystem-M}
  &(M):&\quad  \dot{U}_{_{M}} - \Divv \SigmaM(\UM) &= 0
  \quad&&\textrm{in}\;\OF\times(0,T],
\end{align}
together with initial and boundary conditions. We note that, with the
proposed notation, the stress from the fluid is transferred to the
structure and the movement of the structure is tracked in the fluid
domain at the common fluid--structure boundary such that:
\begin{align}
  \label{selim:eq:ALEtraction-1}
  (J_{_{M}}\;(\sigmaF\circ\PhiM) \cdot F_{_{M}}^{-\top})\cdot
  N_{_{F}} &= - \SigmaS\cdot N_{_{S}}
  \quad &&\textrm{on}\;\Gamma_{_{FS}},\\[2.5pt]
  \label{selim:eq:ALEtraction-2}
  \uF\circ\PhiM &= \dot{U}_{_{S}}
  \quad &&\textrm{on}\;\Gamma_{_{FS}}.
\end{align}
Thus, \eqref{selim:eq:ALEtraction-1}--\eqref{selim:eq:ALEtraction-2} transfer data between all the equations in the FSI system~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M} at the common FSI interface.

In the numerical solution of the fluid problem $(f)$, we compensate
for the additional (unphysical) mesh movement $\dot{u}_{_{M}}$ in the
fluid domain $\oF(t)$ introduced by the mesh equation $(M)$.  The
resulting discrete finite element form of the convective term of the
fluid problem takes the form $\rhoF(\dotuF^{hk} +
\graduF^{hk}\cdot(\uF^{hk} - \dot{u}_{_{M}}^{hk}))$. This additional mesh
movement is a pure numerical artifact and is not a part of the
continuum representation of the FSI problem.

%------------------------------------------------------------------------------
\section{The FSI solver}
\label{selim:sec:primalsolver}

The proposed system of equations that defines the fully coupled FSI
problem~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M} is a partitioned system, where the
subproblems $(f),(S),(M)$ are connected at the fluid--structure interface
through the boundary conditions in~\eqref{selim:eq:ALEtraction-1}--\eqref{selim:eq:ALEtraction-2}. To
solve such a system, we utilize a fixed point iteration. The algorithm
reads as follows and is illustrated in Figure~\ref{selim:fig:fp}.

\pagebreak

\begin{enumerate}
  \item Solve the fluid problem $(f)$.

  \item Transfer the fluid stress using~\eqref{selim:eq:ALEtraction-1}
  and solve the structure problem $(S)$.

  \item Solve the mesh problem $(M)$ and update the fluid domain.

  \item Repeat steps (1)--(3) until convergence.

  \item Move on to the next time step.
\end{enumerate}
%%
We note that one may, alternatively, start each time step with an
extrapolation of the motion of the structure domain, followed by a
solution of the mesh problem, then the fluid problem etc. This might
lead to fewer iterations. However, for this work, we have adopted the
simple strategy described above.

\begin{figure}[!t]
%\bwfig
  \centering
  %\includegraphics[width=\largefig]{chapters/selim/pdf/primal.pdf}
  \includegraphics{0001335362/272415_1_en_29_fig2_print.eps}
  \caption{A partitioned approach to solving the FSI problem. In each
    time step $k_n$, the three subproblems are solved iteratively
    using a simple fixed point method. The fluid problem is first
    solved on the given current fluid domain $\oF(t)$ and the stress
    $\sigmaF$ is evaluated and mapped back to the
    structure problem in the reference domain. In the structure
    reference domain $\Omega_{_{S}}$, the fluid stress is set as a
    Neumann boundary condition and the structure problem is solved for the
    given fluid stress. The structure displacement field is then set
    as a Dirichlet boundary condition at the common fluid--structure
    boundary for the mesh equation in the fluid reference domain
    $\Omega_{_{F}}$. Having obtained the mesh solution, the solution
    is pushed forward to the current fluid domain and thus defines the
    new deformed current domain.}\label{selim:fig:fp}
\end{figure}

\index{CBC.Solve}
\index{CBC.Flow}
\index{CBC.Twist}

The two subproblems $(f)$, $(S)$ define a
classic set of equations from fluid and structure mechanics. To solve the
coupled system, a solver framework for handling both types of physics
is needed. For this purpose, we have used the multiphysics framework
\emp{CBC.Solve} developed at the Center for Biomedical Computing at
Simula Research Laboratory. Currently, \emp{CBC.Solve} consists of
two core components; \emp{CBC.Flow} and \emp{CBC.Twist}.  These are
frameworks explicitly developed for solving fluid mechanics problems and
structure mechanics problems, respectively.  In the subsequent sections,
we will briefly explain these frameworks and the code that solves the
FSI problem~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}.


%------------------------------------------------------------------------------
\vspace*{-3pt}\subsection{Fluid subproblem}

The fluid subproblem in~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-f-con} is solved using the
\emp{CBC.Solve} module \emp{CBC.Flow}. The fluid problem can be
solved in an Eulerian coordinate system or in an ALE coordinate
system, and the solver is based on the stress formulation of the
so-called Incremental Pressure Correction Scheme
(IPCS)~\citep{Goda1979}. The fluid velocity $\uF$ and the fluid
pressure $\pF$ are discretized in space using Taylor--Hood
elements. The resulting nonlinear variational problem is solved in
three steps. In the first step, the tentative fluid velocity is
computed from the momentum equation using the previously known
pressure. After this step, the pressure at the current time step is
computed and corrected using the continuity equation. Finally, in the
third step, the velocity is corrected using the corrected pressure.
The implementation is illustrated with a code segment from the class
\emp{NavierStokesSolver} in Figure~\ref{selim:fig:fluidsolver}. For a
more comprehensive discussion on how to solve and implement different
solvers for the incompressible Navier--Stokes equations in FEniCS, see
Chapter~\ref{chap:kvs-1}.
\begin{figure}[!t]
%\bwfig
%%%\begin{python}
%%%class NavierStokesSolver(CBCSolver):
%%%    "Navier-Stokes solver"
%%%
%%%    def __init__(self, problem):
%%%        "Initialize Navier-Stokes solver"
%%%
%%%        ...
%%%
%%%        # Tentative velocity step (sigma formulation)
%%%        U = 0.5*(u0 + u)
%%%        F1 = rho*(1/k)*inner(u - u0, v)*dx \
%%%           + rho*inner(grad(u0)*(u0 - w), v)*dx \
%%%           + inner(sigma(U, p0), epsilon(v))*dx \
%%%           + inner(p0*n, v)*ds \
%%%           - mu*inner(grad(U).T*n, v)*ds \
%%%           - inner(f, v)*dx
%%%        a1 = lhs(F1)
%%%        L1 = rhs(F1)
%%%
%%%        # Pressure correction
%%%        a2 = inner(k*grad(p), grad(q))*dx
%%%        L2 = inner(k*grad(p0), grad(q))*dx \
%%%           - div(u1)*q*dx
%%%
%%%        # Velocity correction
%%%        a3 = inner(u, v)*dx
%%%        L3 = inner(u1, v)*dx \
%%%           + inner(k*grad(p0 - p1), v)*dx
%%%\end{python}
\includegraphics{0001335362/272415_1_en_29_fig3_print.eps}
\caption{A code segment of the fluid solver in \emp{CBC.flow}. The
  momentum equation is multiplied with a test function \emp{v} and
  the continuity equation is multiplied with a test function
  \emp{q}. In the first step, the tentative velocity is computed
  from the momentum equation using a fully implicit formulation of the
  convective term and the previously computed pressure. Here, \emp{w}
  denotes the mesh velocity $\dot{u}_{_{M}}$. In the next step, the
  pressure is corrected with the continuity equation based on the
  computed velocity \emp{u1} from the first step. Finally, the
  velocity is corrected using the corrected pressure.}
\label{selim:fig:fluidsolver}
\end{figure}

\subsection{Structure subproblem}

\emp{CBC.Twist} is a solver collection for structure mechanics
problems. This module solves the given structure problem in a
Lagrangian coordinate system.  The solver allows the user to easily
pose problems and provides many standard material models, including
St.~Venant--Kirchhoff, Mooney--Rivlin, neo-Hookean, Isihara, Biderman
and Gent--Thomas. New models may be added easily since the interface
allows the user to provide an energy functional as a function of a
suitable kinematic measure, such as the Green--Lagrange strain. Both a
static and an energy-momentum preserving time-dependent solver are
provided. The space discretization relies upon first order Lagrange
elements and for the time discretization several different schemes are
available, such as the \cgone{}
method~\citep{ErikssonEstepHansboEtAl1996} or the ``HHT''
method~\citep{HilberHughesTaylor1977}.  In the \cgone{} method, used in
this chapter, the structure problem is re-written as a first order
system in time by introducing the additional equation $P_{_{S}} -
\dot{U}_{_{S}} = 0$ to the structure equation~\eqref{selim:eq:FSIsystem-S}. The structure stress tensor, regardless
of material model, is given as the first Piola--Kirchhoff tensor and
the nonlinear variational problem is solved using Newton's method.
The implementation of the \cgone{} version is illustrated in the code
segment from the class \emp{CG1MomentumBalanceSolver} in
Figure~\ref{selim:fig:structuresolver}. For a more comprehensive
discussion of how to solve structure problems using \emp{CBC.Twist},
and especially how to implement different material models, see
Chapter~\ref{chap:narayanan}.

\begin{figure}[!t]
%\bwfig
%%\begin{python}
%%class CG1MomentumBalanceSolver(CBCSolver):
%%    def __init__(self, problem):
%%        ...
%%
%%        # The variational form corresponding to hyperelasticity
%%        L = rho0*inner(p - p0, v)*dx + k*inner(sigma, grad(v))*dx \
%%          - k*inner(b, v)*dx + inner(u - u0, q)*dx \
%%          - k*inner(p_mid, q)*dx
%%
%%        # Add contributions form the Neumann boundary
%%        neumann_conditions = problem.neumann_conditions()
%%        neumann_boundaries = problem.neumann_boundaries()
%%
%%        boundary = MeshFunction("uint", mesh, mesh.topology().dim() - 1)
%%        boundary.set_all(len(neumann_boundaries) + 1)
%%
%%        for (i, neumann_boundary) in enumerate(neumann_boundaries):
%%            compiled_boundary = compile_subdomains(neumann_boundary)
%%            compiled_boundary.mark(boundary, i)
%%            L = L - k*inner(v, neumann_conditions[i])*ds(i)
%%
%%        a = derivative(L, U, dU)
%%\end{python}
\includegraphics{0001335362/272415_1_en_29_fig4_print.eps}
\caption{A code segment from the \cgone{} version of the structure
  solver \emp{CBC.Twist}. In the \cgone{} method, the structure problem
  is re-written as a first order system in time by introducing the
  additional equation $P_{_{S}} - \dot{U}_{_{S}} = 0$ to the structure
  equation~\eqref{selim:eq:FSIsystem-S}. The two resulting
  equations are multiplied with test functions \emp{v} and \emp{q}
  respectively, and adding the two equations yields the nonlinear
  variational form \emp{L}. The nonlinear variational form \emp{L}
  contains the structure velocity \emp{p} and the first
  Piola--Kirchhoff stress tensor \emp{sigma} (which is a function of
  the structure displacement $\US$).  The nonlinear form \emp{L} is
  linearized using the FEniCS function \emp{derivative} where \emp{U}
  represents the mixed finite element function containing the structure
  solution $(\US, P_{_{S}})$.  We note that Neumann conditions, such a
  fluid stress, are imposed in the variational form \emp{L} while the
  Dirichlet conditions are set directly in the Newton solver. We also
  note that the proposed variational form holds for a large amount of
  different structure models, in which the first Piola--Kirchhoff stress
  tensor \emp{sigma} is given by an appropriate material model.}
\label{selim:fig:structuresolver}
\end{figure}

%------------------------------------------------------------------------------
\subsection{Mesh subproblem}

The linear mesh subproblem is solved using first order Lagrange
elements in space along with a standard \cgone{} formulation in time. We
note that although piecewise quadratic functions are used to
approximate the velocity in the fluid problem, an affine mapping is
used to map the elements in the finite element discretization. It is
therefore suitable to approximate the mesh problem using piecewise
linears (not quadratics); see~\citet{FormaggiaNobile1999}.

The implementation of the variational forms describing the mesh
subproblem is illustrated in Figure~\ref{selim:fig:meshsolver}.
\begin{figure}[!t]
%\bwfig
%%%\begin{python}
%%%# Define cG(1) scheme for time-stepping
%%%a = inner(u, v)*dx + 0.5*k*inner(sigma(u), sym(grad(v)))*dx
%%%L = inner(u0, v)*dx-0.5*k*inner(sigma(u0), sym(grad(v)))*dx
%%%\end{python}
\includegraphics{0001335362/272415_1_en_29_fig5_print.eps}
\caption{A code segment of the mesh solver \emp{MeshSolver}.}
\label{selim:fig:meshsolver}
\end{figure}
The Dirichlet boundary conditions on the mesh subproblem are imposed
weakly through the introduction of the Lagrange multiplier,
$P_{_{M}}$. This choice introduces coupling between the mesh and
structure subproblems in the linearized (adjoint) dual problem which
is described below.

%------------------------------------------------------------------------------
\section{Duality--based error control}
\index{error estimation}
\index{dual problem}

As mentioned in the beginning of this chapter, in many cases we are
only interested in computing one output quantity of the fully coupled
FSI system. This output quantity is commonly referred to as the goal
functional.  To ensure a high level of accuracy of the functional of
interest, the error in the goal functional needs to be controlled. In
finite element discretizations, \apost{} error analysis
provides a general framework for controlling the approximation error
of the solution.  The extension of the classical \apost{}
error analysis to estimate the error in a goal functional has been
under development over the past two decades, and the technique
originates form \citet{ErikssonEstepEtAl1995,
BeckerRannacher2001}. This technique is based on the solution of an
auxiliary linearized dual (adjoint) problem in order to estimate the
error in a given goal functional. By solving the dual problem, one may
construct an adaptive algorithm that efficiently targets the
computation of a specific goal functional $\M$, such that
\begin{equation}
  \label{selim:eq:goalTOL}
|\M(U)-\M(U^{hk})| \leqslant \mathrm{TOL}.
\end{equation}
Here, $ U-U^{hk} \equiv e$ is the error of the finite element solution
in space $(h)$ and time $(k)$, and $\mathrm{TOL}>0$ is a user-defined
tolerance.  To define the dual problem for the FSI
problem~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}, we pull the fluid subproblem
$(f)$ back from the current fluid domain $\oF(t)$ to the fluid reference
domain $\OF$ using the map $\PhiM$:
\begin{equation}
  \label{selim:eq:pullback}
  \begin{CD}
    (F) @<\PhiM^{-1}<< (f).
  \end{CD}
\end{equation}
With the fluid problem $(F)$ defined in the reference domain, all the
three subproblems $(F,S,M)$ are posed in the reference domain
$\Omega$, and we may thus formulate a monolithic counterpart to the
FSI problem~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}. The abstract nonlinear variational form reads: find $U\equiv \{\UF, \PF, \US, \PS,\break \UM,
P_{_{M}}\}\in V$ such that
\begin{equation}
\label{selim:eq:monolithic}
a(U;v) = L(v),
\end{equation}
for all $v\equiv\{ v_{_{F}}, q_{_{F}}, v_{_{S}}, q_{_{S}}, v_{_{M}}, q_{_{M}}
\}\in\hat{V}$, where the trial and test spaces $(V,\hat{V})$ are
associated with the geometrically conforming parts of $\Omega_{_{F}}$
and $\Omega_{_{S}}$, respectively. By introducing the linearized
variational form $a'(U; \delta U,v ) \equiv \frac{\partial
  a(U;v)}{\partial U}\delta U$, we note that by the chain rule
\begin{equation}
\begin{split}
\overline{a'}(e, v)  &\equiv \int_0^1 a'(sU + (1-s)U^{hk}; e,
v) \ds
\\
&= \int_0^1 \frac{\textrm{d}}{\ds} a (sU + (1-s)U^{hk}; v) \ds
\\
&= L(v) - a(U^{hk};v)
\\ &\equiv  r(v),
\end{split}
\end{equation}
where $r(\cdot)$ is the (weak) residual of~\eqref{selim:eq:monolithic}.
We now define the following dual problem: find the dual solution
$Z\equiv \{ Z_{_{F}}, Y_{_{F}}, Z_{_{S}}, Y_{_{S}}, Z_{_{M}},
Y_{_{M}}\}\in V^*$ such that\vspace*{2pt}
\begin{equation}
  \label{selim:eq:dual}
  \overline{a'}^{*}(Z, v) = \M(v),\vspace*{2pt}
\end{equation}
for all $v\equiv \{ v_{_{F}}, q_{_{F}}, v_{_{S}}, q_{_{S}}, v_{_{M}}, q_{_{M}}
\}\in\hat{V}^*$, where the dual test and trial spaces are to be
defined below. We assume that the goal functional in \eqref{selim:eq:dual} can
expressed in the form\vspace*{2pt}
\begin{equation}
\M(v)  \equiv \langle \psi^T,\;  v(\cdot, T) \rangle +
\int_0^T \langle \psi^t,\; v \rangle \dt,\vspace*{2pt}
\end{equation}
where $(\psi^T, \psi^t)$ are suitable Riesz representers for the
goal functional. Based on the solution of the dual
problem \eqref{selim:eq:dual} and by inserting $v=e$,
we obtain the following computable error representation:\vspace*{2pt}
\begin{equation}
\label{selim:eq:representation}
\begin{split}
\M(e) &= \overline{a'}^{*}(Z ,e)
\\[1.5pt]
&= \overline{a'}(e, Z)
\\[1.5pt]
&= L(Z) - a(U_{hk}; Z)
\\[1.5pt]
&= r(Z);
\end{split}\vspace*{2pt}
\end{equation}
that is, the error is the (weak) residual of the dual solution.  The
dual problem~\eqref{selim:eq:dual} measures the sensitivity of the
problem with respect to the given goal functional. The dual solution
$Z$ contains the dual variables where, for instance, $(Z_{_{F}},
Y_{_{F}})$ represents the dual fluid velocity and dual fluid pressure.
The additional dual variable $Y_{_{M}}$ represents the weakly imposed
dual mesh Lagrange multiplier at the common fluid--structure
interface.  This term is added to account for the coupling between the
mesh and structure equations of the FSI problem.  We notice that in
order for the error representation~\eqref{selim:eq:representation} to
be consistent, the corresponding dual trial and test spaces are
defined as $(V^*,\hat{V}^*)=(\hat{V}, V_0)$, where  $V_0 = \{v-w:\;v,w\in V
\}$. We interpret the Riesz representer $\psi^T$ is an initial condition in
the dual problem and that the dual problem~\eqref{selim:eq:dual} runs
backwards in time. In the computations, the stated dual
problem~\eqref{selim:eq:dual} is replaced by the approximated
linearized form $\overline{a'}^{*}(Z, v) \equiv a'^{*}(U; Z, v)
\approx a'^{*}(U^{hk}; Z, v)  = a'(U^{hk}; v, Z)$.

We may express the dual problem on block form as\vspace*{2pt}
\begin{equation}
\label{selim:eq:dualsystem}
\left[\begin{array}{ccc} \hat{v}_{_{F}} & \hat{v}_{_{S}} & \hat{v}_{_{M}}
  \end{array} \right]
\left[\begin{array}{lll} \AFF & \textcolor{Grey}{\AFS} & \AFM
    \\ \ASF & \ASS & \ASM \\ \textcolor{Grey}{\AMF} & \AMS &
    \AMM
\end{array} \right]^{\top}
\left[ \begin{array}{c} \hat{Z}_{_{F}} \\ \hat{Z}_{_{S}}
    \\ \hat{Z}_{_{M}} \end{array} \right] =\left[ \begin{array}{l}
    \M_{_{F}}\\ \M_{{_S}}\\ \M_{_{M}} \end{array} \right].\vspace*{2pt}
\end{equation}
Here, $\hat{v}_{_{F}} = (v_{_{F}}, q_{_{F}})$ represents the fluid
test functions, $\AFF$ denotes the fluid problem linearized around the
fluid variables $(\UF,\PF)$, $\hat{Z}_{_{F}} = (Z_{_{F}}, Y_{_{F}})$
are the dual fluid variables and $\M_{_{F}}$ the fluid goal functional
and so on. The interpretation of the individual blocks
in~\eqref{selim:eq:dualsystem} is that, for instance,
$\hat{v}_{_{F}}\ASF^{\top}\hat{Z}_{_{S}} $ is interpreted as
$\overline{a'}^*_{_{SF}}(\hat{Z}_{_{S}}, \hat{v}_{_{F}})$ which is the
(adjoint) structure form linearized around the fluid variables.  We
notice that the $\textcolor{Grey}{\AFS}$ is zero since the fluid
problem linearized around the structure variables are identically
zero. Thus, the grey colored entries are by definition zero and that
$\AMS \neq 0$ by the introduction of the dual mesh Lagrange multiplier
$Y_{_{M}}$.

To be able to bound the errors in space and time, we
add and subtract suitable interpolants $(\pi_h, \pi_{hk})$ in space
and space/time in the error
representation~\eqref{selim:eq:representation} to obtain the following
\apost{} error estimate: $|\M(U) - \M(U^{hk})| \leqslant  E_h +
E_k + E_c$, where
%% \begin{equation}
%% \label{selim:eq:aposteriori}
%% \begin{split}
%% E_h &\equiv \sum_{n=1}^{N}\int_{I_n} \sum_{T\in\mathcal{T}_h}| \langle
%% R_T,\; Z - \pi_h Z \rangle_T |+ | \langle \tfrac{1}{2}\llbracket R_{\partial T}
%% \rrbracket,\; Z - \pi_h Z \rangle _{\partial T}|\dt,\\\\ E_k &\equiv
%% \;\mathcal{S}(T)\max_{[0,T]}\;\{k_n | r_k ^n|\},\\\\ E_c &\equiv
%% |r(\pi_{hk}Z)|.
%% \end{split}
%% \end{equation}
\begin{align}
  \label{selim:eq:aposteriori-Eh}
   E_h &\equiv \sum_{n=1}^{N}\int_{I_n} \sum_{T\in\mathcal{T}_h}| \langle
   R_T,\; Z - \pi_h Z \rangle_T |+ | \langle \tfrac{1}{2}\llbracket R_{\partial T}
   \rrbracket,\; Z - \pi_h Z \rangle _{\partial T}|\dt,
   \\\nonumber\\[-4pt]
   \label{selim:eq:aposteriori-Ek}
   E_k &\equiv\;\mathcal{S}(T)\max_{[0,T]}\;\{k_n | r_k ^n|\},
   \\\nonumber\\[-4pt]
   \label{selim:eq:aposteriori-Ec}
   E_c &\equiv |r(\pi_{hk}Z)|.
\end{align}
Here, $E_h$ estimates the space discretization error which on each
space-time slab $S_n = \mathcal{T}_h \times I_n$ is expressed as the sum
of error indicators $R_T$ and $R_{\partial T}$ from the cells of the
mesh, weighted by the interpolation error of the dual solution. The
implementation of these indicators is illustrated in Figure~\ref{selim:fig:strong_residuals}.

\begin{figure}[!t]
%\bwfig
%%%\begin{python}
%%%# Fluid residual contributions
%%%R_F0 = w*inner(EZ_F - Z_F, Dt_U_F - div(Sigma_F))*dx_F
%%%R_F1 = avg(w)*inner(EZ_F("+") - Z_F("+"),
%%%              jump(Sigma_F, N_F))*dS_F
%%%
%%%R_F2 = w*inner(EZ_F - Z_F, dot(Sigma_F, N_F))*ds
%%%R_F3 = w*inner(EY_F - Y_F, div(J(U_M)*
%%%         dot(inv(F(U_M)), U_F)))*dx_F
%%%
%%%# Structure residual contributions
%%%R_S0 = w*inner(EZ_S - Z_S, Dt_P_S - div(Sigma_S))*dx_S
%%%R_S1 = avg(w)*inner(EZ_S("-") - Z_S("-"),
%%%             jump(Sigma_S, N_S))*dS_S
%%%
%%%R_S2 = w("-")*inner(EZ_S("-") - Z_S("-"),
%%%             dot(Sigma_S("-") - Sigma_F("+"),
%%%             -N_F("+")))*d_FSI
%%%
%%%R_S3 = w*inner(EY_S - Y_S, Dt_U_S - P_S)*dx_S
%%%
%%%# Mesh residual contributions
%%%R_M0 = w*inner(EZ_M - Z_M, Dt_U_M - div(Sigma_M))*dx_F
%%%R_M1 = avg(w)*inner(EZ_M("+") - Z_M("+"),
%%%              jump(Sigma_M, N_F))*dS_F
%%%
%%%R_M2 = w("+")*inner(EY_M - Y_M, U_M - U_S)("+")*d_FSI
%%%\end{python}
\includegraphics{0001335362/272415_1_en_29_fig6_print.eps}
\caption{A code segment illustrating the element-wise space error
  indicators. The indicators consist of three parts where each
  subproblem is represented. These estimates are obtained by element
  wise integration by parts of the finite element formulation which is
  weighted by the dual solution. This results in element indicators
  $R_T$ defined on the cells and jump terms $R_{\partial T}$ across
  element edges. Here, \emp{w} represents a discontinuous function of
  order zero and \emp{jump} denotes the jump across an element edge
  \emp{dS}. The difference $Z -\pi_h Z$ is approximated with \emp{EZ -
    Z} where \emp{EZ} is the extrapolated finite element approximation
  on a richer space and \emp{Z} is the finite element approximation.}
\label{selim:fig:strong_residuals}
\end{figure}
The time discretization error estimate $E_k$ consists of the local time
step size $k_n$ multiplied with a local algebraic residual
$r_k^n$ and the global stability factor $\mathcal{S}(T) \approx
\int_0^T \| \dot{Z} \|_{l^2}\dt$. Finally, the computational error
estimate $E_c$ accounts for the error introduced when the proposed
Galerkin method is solved using a non-Galerkin method, e.g. the IPCS
for the fluid subproblem. Also, in addition to the proposed mesh
equation, an additional local mesh smoothing is added to the fluid
mesh.  For a more comprehensive discussion and derivation of this
\apost{} estimate see \citet{SelimLogg2011a}.

%------------------------------------------------------------------------------
\subsection{The adaptive algorithm}
\index{adaptivity}

With the \apost{} error estimate presented
in~\eqref{selim:eq:aposteriori-Eh}--\eqref{selim:eq:aposteriori-Ec}, we construct an algorithm based on a
feedback process that provides an adaptive space-time discretization
such that~\eqref{selim:eq:goalTOL} holds. In order to determine the
stopping criteria for the space and time discretizations, the user
defined tolerance $\mathrm{TOL}$ needs to be weighted such that
\begin{equation}
\mathrm{TOL} = \mathrm{TOL}_h + \mathrm{TOL}_k + \mathrm{TOL}_c,
\end{equation}
where $\mathrm{TOL}_h = w_h \mathrm{TOL}, \;\mathrm{TOL}_k = w_k
\mathrm{TOL}, \;\mathrm{TOL}_c = w_c \mathrm{TOL}$.  We here take $w_h
= w_k = w_c = 1/3$. The weight $w_c$ affects the tolerance used for
the fixed point algorithm when
solving~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}. Based on the spatial error
estimate $E_h$, we refine the mesh until $E_h \leqslant \mathrm{TOL}_h$.
There are various ways in which refine the mesh and to determine which
elements to refine. In the examples to come, we have adopted the
Rivara recursive bisection algorithm as the refinement algorithm
and the so-called
D\"{o}rfler \citep{Dorfler1996} marking strategy. The D\"{o}rfler
marking strategy is based on the idea that for a given
$\alpha\in(0,1]$, a minimum number of elements $N$ is determined
such that
\begin{equation}
  \label{selim:eq:dorfler}
\sum_{i=1}^{N}\eta_{T_i} \geqslant  \alpha \sum_{T\in\mathcal{T}_h}\eta_T ,
\end{equation}
where $\{ \eta_{T_{i}}\}_{i = 1}^{|\mathcal{T}_h|}$ is a list of error
indicators sorted in decreasing order. The adaptive time step size is
based on the error estimate $E_k$ and connects the global error to the
local error over time. As a first approximation, we may choose the
local time step size such that
\begin{equation}
\label{selim:eq:timestep1}
k_n = \mathrm{TOL}_k /(| r_k^{n-1} |\; \mathcal{S}(T)).
\end{equation}
However, this particular choice of time step size introduces
oscillations in the time step size since a small algebraic residual
gives a large time step which results in a large residual and so
on. To overcome this behavior, we use a smoothed
version \citep{Logg2004}, where~\eqref{selim:eq:timestep1} is replaced
by
\begin{equation}
\label{selim:eq:timestep2}
k_n = \frac{2\bar{k}_n k_{n-1}}{\bar{k}_n + k_{n-1}},
\end{equation}
and $\bar{k}_n = \mathrm{TOL}_k/(| r_k^{n-1} |
\;\mathcal{S}(T))$. Finally, the estimate for the computational error
$E_c$ is only considered in the stopping criterion for the total
error.

The main outline of the adaptive FSI algorithm is depicted in
Figure~\ref{selim:fig:adaptiveMAP}. In the \emp{FSISolver}, the FSI
problem~~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}
(referred to as the primal problem)
is solved in the module \emp{PrimalSolver}, which solves and
transfers data from the three subproblems defined in
\emp{CBC.Twist}, \emp{CBC.Flow} and \emp{MeshSolver}. Once
the entire primal problem is solved, the primal data is passed to the
\emp{DualSolver}. In the dual solver, the linearized dual
problem~\eqref{selim:eq:dual} is solved. The primal and dual solutions
are passed to the module \emp{Residuals} where the error
estimate~\eqref{selim:eq:aposteriori-Eh}--\eqref{selim:eq:aposteriori-Ec} is evaluated. The code for the
\emp{FSISolver} is illustrated in
Figure~\ref{selim:fig:FSISolver-1} and Figure~\ref{selim:fig:FSISolver-2}.


\begin{figure}[!p]
%\bwfig
\vspace*{-8pt}
\centering
  %\includegraphics[width=\largefig]{chapters/selim/pdf/adaptive.pdf}
  \includegraphics{0001335362/272415_1_en_29_fig7_print.eps}
  \caption{A schematic picture of the adaptive FSI algorithm. The primal
    problem~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}
 is solved iteratively in the
    \emp{PrimalSolver} and the solution $U$ is passed to the
    \emp{FSISolver}. The dynamic time step $k_n$ is calculated for
    each time step in the iterative solver \emp{PrimalSolver}
    using~\eqref{selim:eq:timestep2} in the module
    \emp{Residuals}. After the primal problem is solved on the entire
    time interval, the dual problem is solved with the same time steps
    as in the primal solution in the module \emp{DualSolver}. Once
    the dual is solved, the error estimates are evaluated and a new mesh
    is created.}
  \label{selim:fig:adaptiveMAP}
\end{figure}

\begin{figure}[!p]
%\bwfig
\centering
\includegraphics{0001335362/272415_1_en_29_fig8_print.eps}
  \caption{The adaptive solver class \emp{FSISolver}. Here, the
    problem specific data is passed through the variable \emp{problem}. In
    the first adaptive loop, we make an initial guess of the stability
    factor $\mathcal{S}(T)=1$ in order to adapt the time step in the
    first loop.  The variable name \emp{error} represents the sum of
    $E_h + E_k + E_c$ in~\eqref{selim:eq:aposteriori-Eh}--\eqref{selim:eq:aposteriori-Ec} and
    \emp{indicator} represents $\eta_T$ in~\eqref{selim:eq:dorfler}.}
%%%\begin{python}
%%%class FSISolver(CBCSolver):
%%%
%%%    def __init__(self, problem):
%%%        "Initialize FSI solver"
%%%            ...
%%%    def solve(self):
%%%        "Solve the FSI problem (main adaptive loop)"
%%%
%%%        # Create empty solution (return value when primal is not solved)
%%%        U = 5*(None,)
%%%
%%%        # Initial guess for stability factor
%%%        ST = 1.0
%%%
%%%        # Adaptive loop
%%%        while True:
%%%            # Solve primal problem
%%%            if self.parameters["solve_primal"]:
%%%                primal_solver = PrimalSolver(self.problem, self.parameters)
%%%                U = primal_solver.solve(ST)
%%%
%%%            else:
%%%                info("Not solving primal problem")
%%%
%%%            # Solve dual problem
%%%            if self.parameters["solve_dual"]:
%%%                dual_solver = DualSolver(self.problem, self.parameters)
%%%                dual_solver.solve()
%%%            else:
%%%                info("Not solving dual problem")
%%%\end{python}
\label{selim:fig:FSISolver-1}\vspace*{6pt}
\end{figure}

To summarize, the adaptive feedback process involves the following steps:
\begin{enumerate}
  \item Solve the partitioned (primal) FSI
  problem~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}
 for $t\in(0,T]$. For each
  time step, determine the local time step size $k_n$ according
  to~\eqref{selim:eq:timestep2}.

\item Solve the dual problem~\eqref{selim:eq:dual} for $t\in[0,T)$
  using the same time step size as in the primal problem.

\pagebreak

\item Evaluate the error estimate~\eqref{selim:eq:aposteriori-Eh}--\eqref{selim:eq:aposteriori-Ec} and
  refine the computational domain in space.

  \item Repeat steps 1 -- 3 until $\M(e)\leqslant \mathrm{TOL}$.
\end{enumerate}



\begin{figure}[!t]
%\bwfig
\includegraphics{0001335362/272415_1_en_29_fig9_print.eps}
\caption{The adaptive solver class \emp{FSISolver}, continued.}
%%%\begin{python}
%%%            # Estimate error and compute error indicators
%%%            if self.parameters["estimate_error"]:
%%%                error, indicators, E_h = estimate_error(self.problem)
%%%            else:
%%%                info("Not estimating error")
%%%                error = 0
%%%
%%%            # Check if error is small enough
%%%            tolerance = self.parameters["tolerance"]
%%%            if error <= tolerance:
%%%                break
%%%            else:
%%%
%%%            # Check if mesh error is small enough
%%%            mesh_tolerance = tolerance * self.problem.space_error_weight()
%%%            if E_h <= mesh_tolerance:
%%%                info("Freezing the current mesh")
%%%            else:
%%%                # Refine mesh
%%%                problem = self.problem
%%%                mesh = refine_mesh(problem,
%%%                                   problem.mesh(),
%%%                                   indicators)
%%%                problem.init_meshes(mesh)
%%%
%%%        # Return solution
%%%        return U
%%%\end{python}
\label{selim:fig:FSISolver-2}
\end{figure}

%------------------------------------------------------------------------------
\section{Numerical examples}

To demonstrate the above described adaptive algorithm, we solve two
simple 2D problems. These problems have different characteristics and
they demonstrate how the proposed adaptive algorithm provides both an
adequate adaptive mesh refinement and time step selection.

%------------------------------------------------------------------------------
\subsection{Channel with flap}

The first problem is a channel flow with a completely immersed
structure called ``the flap''. The computational domain is given by
$\Omega = (0, 1)\times (0,4)$, with the structure domain $\OS = (1.4,
1.6)\times (0, 0.5)$ and the fluid domain $\OF = (\Omega\setminus
\OS)^{\circ}$. For boundary conditions, we consider a pressure driven
flow and the flap is attached at the channel wall. As goal functional,
we have used the average displacement of the structure in the positive
$x_1$-direction; that is,
\begin{equation}
\label{selim:eq:goalfunctional_channel}
\M_{_{S}}(v_{_{S}}) = \int_0^T \langle \psi^t_{_{S}},\;
v_{_{S}}\rangle \dt,
\end{equation}
where $\psi^t_{_{S}} = (1,0)$. The physical parameters related to the
problem is set to $(\rhoF,\mu_{_{F}}) = (1, 0.02)$,
$(\rho_{_{S}},\mu_{_{S}}, \lambda_{_{S}}) = \tfrac{1}{4}(15, 75, 125)$
and $(\mu_{_{M}}, \lambda_{_{M}}) = (3.8461, 5.76)$. The
discretization parameters are set to $(\mathrm{TOL}, w_h, w_k,w_c) = (0.05, 0.45, 0.45, 0.1)$ with an initial time step size $0.02$ and
final time $T=0.5$. The
adaptive primal FSI solution is depicted in
Figure~\ref{selim:fig:primal_channel} and the corresponding dual
solutions are illustrated in Figure~\ref{selim:fig:dual_channel_1}
and in Figure~\ref{selim:fig:dual_channel_2}.

\begin{figure}[!t]
  \centering
  \includegraphics{0001335362/272415_1_en_29_fig10_print.tif}
    %\subfloat[]{\label{subfig:1:a}\includegraphics[width=\mediumfig]{chapters/selim/png/new_channel.png}} %\\
  %\subfloat[]{\label{subfig:1:b}\includegraphics[width=\mediumfig]{chapters/selim/png/channel_test_zoom.png}}
  \caption{The adaptive FSI solution to the channel with flap problem
     depicted in the current domain $\omega(t)$ at final time
     $t=0.5$. In Figure~(a), the fluid velocity solution
     is illustrated using streamlines. A close view of the adaptive
     mesh is given in Figure~(b). The mesh is refined in
     the immediate area around the structure.}
\label{selim:fig:primal_channel}
\end{figure}

\begin{figure}[!p]
%\bwfig
  \centering
%\subfloat[$Z_{_{F}}$]{\label{fig:a}\includegraphics[width=\largefig]{chapters/selim/png/channelZF.png}} %\\
%  \subfloat[$Z_{_{S}}$]{\label{fig:b}\includegraphics[width=\largefig]{chapters/selim/png/channelZS.png}}
\includegraphics{0001335362/272415_1_en_29_fig11_print.eps}
  \caption{The dual fluid velocity solution $Z_{_{F}}$ and the dual
    structure solution $Z_{_{S}}$ at the ``final time'' $t=0$ in the
    reference domain $\Omega$.  Since the only driving force of the
    fully coupled dual problem is the goal
    functional~\eqref{selim:eq:goalfunctional_channel}, the dual fluid
    $Z_{_{F}}$ is concentrated around the top left corner of the
    structure where the structure displacement is large. The dual
    structure displacement $Z_{_{S}}$ illustrates the choice of goal
    functional in~\eqref{selim:eq:goalfunctional_channel}.}
\label{selim:fig:dual_channel_1}\vspace*{8pt}
\end{figure}

\begin{figure}[!p]
%\bwfig
\centering
\includegraphics{0001335362/272415_1_en_29_fig12_print.tif}
\caption{The dual mesh displacement $Z_{_{M}}$ to the channel with
    flap problem solved in the reference domain $\Omega$. The dual mesh
      displacement is large close to the top right corner of the
      structure. This is expected since the mesh in the current domain
      $\omega(t)$ is significantly compressed in this region.}
\label{selim:fig:dual_channel_2}
\end{figure}

%------------------------------------------------------------------------------
\subsection{Driven cavity with an elastic bottom}

The second problem is a driven cavity with an elastic bottom. Here,
the computational domain is given by $\Omega = (0,2)\times (0,2)$,
with structure domain $\OS = (0, 2)\times (0, 0.5)$ and the fluid
domain $\OF = (\Omega\setminus \OS)^{\circ}$. At the top of the fluid
domain, the fluid has the regularized tangential velocity profile in
$x_1$-direction
\begin{equation}
\uF =
\left\{
\begin{array}{lcl}
2x,& &x\in[0, 0.25],\\
0.5,& &x\in(0.25 ,1.75),\\
2(2-x),&  &x\in[1.75, 2],
\end{array}
\right.
\end{equation}
for all $t \in [0,5]$. The structure is attached at the bottom and the
goal functional is set as the average structure displacement in the positive
$x_2$-direction; that is,
\begin{equation}
\label{selim:eq:goalfunctional_cavity}
\M_{_{S}}(v_{_{S}}) = \int_0^T \langle \psi^t_{_{S}},\; v_{_{S}}\rangle \dt,
\end{equation}
where $\psi^t_{_{S}}=(0,1)$.  The physical parameters related to the
problem is set to $(\rhoF,\mu_{_{F}}) = (1, 1)$,
$(\rho_{_{S}},\mu_{_{S}}, \lambda_{_{S}}) = (2, 3, 3)$ and
$(\mu_{_{M}}, \lambda_{_{M}}) = (3.8461, 5.76)$. The discretization
parameters are set to\break $(\mathrm{TOL}, w_h, w_k,w_c) = (0.5, 0.45,
0.45, 0.1)$ with an initial time step size $0.05$.  In contrast to the
previous problem, the solution, and in particular the structure
displacement, varies substantially over time. The adaptive primal FSI
solution is depicted in~Figure~\ref{selim:fig:primal_cavity} and the
dynamic time step size is illustrated
in~Figure~\ref{selim:fig:cavity_timestep}.

\begin{figure}[!t]
\centering
\includegraphics{0001335362/272415_1_en_29_fig13_print.tif}
  %\subfloat[]{\label{subfig:2:a}\includegraphics[width=\largefig]{chapters/selim/png/new_cavity.png}} \\
  %\subfloat[]{\label{subfig:2:b}\includegraphics[width=\largefig]{chapters/selim/png/zoom_cavity.png}}
  \caption{Figure (a) shows the adaptive FSI solution to the driven
    cavity problem with an elastic bottom at time $t=2$. The structure
    does not reach a steady position; instead the structure moves up and
    down at the common fluid--structure boundary. Figure~(b) is a close
    up view of the refined mesh at the FSI boundary.}
\label{selim:fig:primal_cavity}\vspace*{9pt}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics{0001335362/272415_1_en_29_fig14_print.eps}
\caption{The time step $k_n$ and the algebraic residual $r_k^n$ as
a function of time. As seen in the picture, the solution has a large
variation in terms of the magnitude of the residual $r_k^n$.}
\label{selim:fig:cavity_timestep}\vspace*{3pt}
\end{figure}

%------------------------------------------------------------------------------
\section{Conclusions}

In this chapter,\enlargethispage{12pt} an adaptive finite element method for FSI
problems has been formulated and its implementation in FEniCS has
been demonstrated. By relating the fully coupled partitioned FSI
problem~~\eqref{selim:eq:FSIsystem-f-mom}--\eqref{selim:eq:FSIsystem-M}
 in a moving domain to a dual
problem~\eqref{selim:eq:dual} posed on a fixed reference domain, an
adapted space and time discretization is obtained.

\index{CBC.Swing}
\index{CBC.Solve}

\emp{CBC.Solve} is a collaboratively developed open source project
(released under the GNU GPL) that is freely available from its source
repository at \url{https://launchpad.net/cbc.solve}. Its only
dependency is a working FEniCS installation. The fluid--structure
interaction solver presented in this chapter is available as CBC.Swing
as part of CBC.Solve. The software is released with the goal that it
will allow users to easily solve fluid problems, structure and FSI
problems. Everyone is encouraged to fetch and try it. Users are also
encouraged to modify the code to better suit their own purposes, and
contribute changes that they think are useful to the community.

\egroup

%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig1_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig2_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig3_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig4_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig5_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig6_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig7_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig8_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig9_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig10_print.tif}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig11_print.eps}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig12_print.tif}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig13_print.tif}
%%%\caption{}
%%%\end{figure}
%%%\begin{figure}[!t]
%%%\includegraphics{0001335362/272415_1_en_29_fig14_print.eps}
%%%\caption{}
%%%\end{figure}
