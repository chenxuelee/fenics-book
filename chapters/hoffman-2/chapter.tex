\fenicschapter{Unicorn: a unified continuum mechanics solver}
              {Unicorn: a unified continuum mechanics solver}
              {Cem Degirmenci, Johan Hoffman, Johan Jansson,
                Niclas Jansson and Murtazo Nazarov}
              {hoffman-2}

This chapter provides a description of the technology in Unicorn
focusing on simple, efficient and general algorithms and software for
the Unified Continuum (UC) concept and the adaptive General Galerkin
(G2) discretization as a unified approach to continuum mechanics. We
describe how Unicorn fits into the FEniCS framework, how it interfaces
to other FEniCS components, what interfaces and functionality Unicorn
provides itself and how the implementation is designed. We also
present some examples in fluid--structure interaction and adaptivity
computed with Unicorn. One such example is presented in
Figure~\ref{fig:flag3D} which shows the simulation of a model problem
of a 3D flexible flag in turbulent flow.

\index{Unicorn}

%------------------------------------------------------------------------------
\section{Background}

Unicorn is solver technology (models, methods, algorithms and
software) with the goal of automated simulation of realistic continuum
mechanics applications, such as drag or lift computation for fixed or
flexible objects (fluid--structure interaction) in turbulent
incompressible or compressible flow. The basis for Unicorn is Unified
Continuum (UC) modeling formulated in Euler (laboratory) coordinates,
together with a G2 (General Galerkin) adaptive stabilized finite
element discretization with a moving mesh for tracking the phase
interfaces. The UC model consists of canonical conservation equations
for mass, momentum, energy and phase over the whole domain as one
continuum, together with a Cauchy stress and phase variable as data
for defining material properties and constitutive equations. Unicorn
formulates and implements the adaptive G2 method applied to the UC
model, and interfaces to other components in the FEniCS chain (FIAT,
FFC, DOLFIN) providing representation of finite element function
spaces, weak forms and mesh, and algorithms such as automated parallel
assembly and linear algebra.

% Comment out until persistent URL can be found
%A live CD with snapshots of Unicorn corresponding to the Unicorn
%chapters in this book is available
%at: \url{ftp://ftp.nada.kth.se/local/jjan/unicorn_fenics-book.iso}.

\begin{figure}
  \center{
    \boxed{
      \includegraphics[width=10cm]{chapters/hoffman-2/pdf/cube556.pdf}
  }}
  \caption{A fluid--structure interaction problem consisting of a flag
    mounted behind a cube in turbulent flow. The plot shows the
    fluid--structure interface, an isosurface of the pressure and a
    cut of the mesh.}
  \label{fig:flag3D}
\end{figure}

The Unicorn software is organized into three parts:
\begin{description}
\item[Library] The Unicorn library provides common solver technology
  such as automated time-stepping, error estimation, adaptivity, mesh
  smoothing and slip/friction boundary conditions.

\item[Solver] The Unicorn solver implements the G2 adaptive
  discretization method for the UC model by formulating the relevant
  weak forms. Currently there are two primary solvers: incompressible
  fluids and solids (including fluid--structure interaction) and
  compressible Euler (only fluid), where the long-term goal is a
  unification of the incompressible and compressible formulations as
  well.

\item[Applications] Associated to the solver(s) are applications such
  as computational experiments and benchmarks with certain geometries,
  coefficients and parameters. These are represented as stand-alone
  programs built on top of the Unicorn solver/library, running in
  either serial or parallel (currently restricted to adaptive
  incompressible flow).
\end{description}

\begin{figure}
  \center{
    \boxed{
      \includegraphics[width=10cm]{chapters/hoffman-2/pdf/compressible3D.pdf}
  }}
  \caption{Example application of adaptive computation of 3D compressible
    flow around a sphere.}
  \label{fig:compr3D}
\end{figure}

\begin{figure}
  \center{
    \boxed{
      \includegraphics[width=10cm]{chapters/hoffman-2/pdf/Hoffman_fig3d.pdf}
  }}
  \caption{Example application of 3D turbulent incompressible flow around
    a cylinder with parallel adaptive computation.}
  \label{fig:parcyl3D}
\end{figure}

\label{chapter:implementation:unicorn}

%------------------------------------------------------------------------------
\section{Unified continuum modeling}

We define, following classical continuum mechanics \citep{Gurtin1981},
a unified continuum model in a fixed Euler coordinate system
consisting of:
\begin{itemize}
\item conservation of mass,
\item conservation of momentum,
\item conservation of energy,
\item phase convection equation,
\item constitutive equations for stress as data,
\end{itemize}
where the stress is the Cauchy (laboratory) stress and the phase is an
indicator function used to determine which constitutive equation and
material parameters to use. Note that in this continuum description
the coordinate system is fixed (Euler), and a phase function
(indicator) is convected according to the phase convection
equation. The mesh is moved with the continuum velocity in the case of
a solid phase to eliminate diffusion of the phase interface. We
elaborate on this below in Section~\ref{sec:hoffman-2:ale}.

We define two variants of this model, incompressible and compressible,
where a future aim is to construct a unified
incompressible/compressible model and solver. We focus here the
presentation on the incompressible model.

We start with a model for conservation of mass and momentum,
together with a convection equation for a phase function $\theta$ over
a space-time domain $Q = \Omega \times [0, T]$ with $\Omega$ an open
domain in $\mathbb{R}^3$ with boundary~$\Gamma$:
\begin{align}
    \frac{\partial \rho}{\partial t} + \frac{\partial}{\partial x_j} (u_j \rho) &= 0, \quad &\text{(mass conservation)}
\\
    \frac{\partial m_i}{\partial t} + \frac{\partial}{\partial x_j} (u_j m_i) &= \frac{\partial}{\partial x_j} \sigma_{ij} + f_i, \quad &\text{(momentum conservation)}
\\
    \frac{\partial \theta}{\partial t} + \frac{\partial}{\partial x_j} (u_j \theta) &= 0, \quad &\text{(phase convection equation)}
\end{align}
together with initial and boundary conditions, where $\rho$ is
density, $m_i = \rho u_i$ is momentum and $u_i$ is velocity.  If we
make the assumption that the continuum is incompressible, that is, $0
= D_t \rho = \frac{\partial}{\partial t} \rho + u_j
\frac{\partial}{\partial x_j} \rho$, it follows that we may express
the incompressible UC equations as
\begin{align}
  \rho\left(\frac{\partial u_i}{\partial t} + u_j \frac{\partial u_i}{\partial x_j} \right) &= \frac{\partial}{\partial x_j} \sigma_{ij} + f_i,
  \\
  \frac{\partial u_j}{\partial x_j} &= 0,
  \\
  \frac{\partial\theta}{\partial t} + \frac{\partial}{\partial x_j} (u_j \theta) &= 0.
\end{align}
The UC modeling framework is simple and compact, close to the
formulation of the original conservation equations, and does not
require mappings between different coordinate systems. This allows
simple manipulation and processing for error estimation and
implementation.

One key design choice of UC modeling is to define the Cauchy stress
$\sigma$ as data, which means the conservation equations are fixed
regardless of the choice of constitutive equation. This gives a
generality in method and software design, where a modification of
constitutive equation impacts the formulation and implementation of
the constitutive equation, but not the formulation and implementation
of the conservation equations.

%------------------------------------------------------------------------------
\section{Space-time general Galerkin discretization}

Adaptive G2 methods (also referred to as Adaptive DNS/LES) have been
used in a number of turbulent flow computations to a very low
computational cost
\citep{Hoffman2005,HoffmanJohnson2006b,Hoffman2006,Hoffman2009,HoffmanJansson2009,VilelaJanssonEtAl2010},
where convergence is obtained in output quantities such as drag, lift
and pressure coefficients and Strouhal numbers, using orders of
magnitude fewer mesh points than with standard LES methods based on
\emph{ad~hoc} refined computational meshes.

\subsection{Standard Galerkin}

We begin by formulating the standard \cgone{}\cgone{} FEM
\citep{ErikssonEstepHansboEtAl1996} with piecewise continuous linear
solution in time and space for \eqref{eq:TotalModel}. We let $w = (u,
  p, \theta)$ denote the exact solution, $W = (U, P, \Theta)$ the
discrete solution, $v = (v^u, v^p, v^\theta)$ the test function and
$R(W) = (R_u(W), R_p(W), R_\theta(W))$ the residual. The residual is defined by
%%
\begin{equation} \label{eq:TotalModel}
  \begin{split}
    R_u(W) &= \rho\left(\frac{\partial U_i}{\partial t} + U_j \frac{\partial U_i}{\partial x_j} \right) - \frac{\partial}{\partial x_j} \Sigma_{ij} - f_i,\\
    R_p(W) &= \frac{\partial U_j}{\partial x_j},\\
    R_\theta(W) &= \frac{\partial\Theta}{\partial t} + U_j \frac{\partial \Theta}{\partial x_j},
  \end{split}
\end{equation}
%%
where $\Sigma$ denotes a discrete piecewise constant stress.

To compute the solution, we enforce the Galerkin orthogonality
\begin{equation}
  \inner{R(W)}{v} = 0
\end{equation}
for all functions $v$ in the test space $\hat{V}_h$ consisting of
piecewise linear continuous functions in space and piecewise constant
discontinuous functions in time. Here $\inner{\cdot}{\cdot}$ denotes
the $L^2$-inner product in space and time.

This standard finite element formulation is unstable for
convection-dominated problems and also suffers from instabilities as a
result of equal order elements for the pressure and velocity. We
therefore add streamline--diffusion stabilization as described below.

The \cgone{}\cgone{} formulation with trapezoid quadrature in time is
equivalent to Crank--Nicolson time-stepping with piecewise linear
elements in space. This has the advantage of being a very simple,
standard, and familiar discrete formulation.

\subsection{Local ALE}
\label{sec:hoffman-2:ale}

If the phase function $\Theta$ has different values on the same cell,
it would lead to an undesirable diffusion of the phase interface. By
introducing a moving space-time finite element space and mesh,
oriented along the characteristics of the convection of the phase
interface \citep[section concerning ``The characteristic Galerkin
  method'']{ErikssonEstepHansboEtAl1996}, we can define the phase
interface at cell facets, allowing the interface to stay
discontinuous.

We thus define a local ALE coordinate map as part of the
discretization on each space-time slab, where it is used to introduce
a mesh velocity. Note that we still compute with global Euler
coordinates, but with a moving mesh.

To be able to define and compensate for an arbitrary mesh velocity
$\beta_h$, we define a local coordinate map $\phi$ on each space-time
slab:
\begin{equation}
  \begin{split}\label{eq:ALEmap}
    \frac{\partial}{\partial t} \phi(t, \bar{x}) &= \beta_h(t, \bar{x}),
    \\
    (x, t) &= \phi(\bar{x}, t).
  \end{split}
\end{equation}
Application of the chain rule gives the relation
\begin{equation}
  \label{eq:ALE2}
  \frac{\partial}{\partial t} U(x,t) + U(x,t) \cdot \nabla U(x,t) = \frac{\partial}{\partial t} \bar{U}(\bar{x},t) +
  (\bar{U}(\bar{x},t) - \beta_h)) \cdot \nabla \bar{U}(\bar{x},t).
\end{equation}

Choosing $\beta_h = U$ in the solid part of the mesh gives a trivial
solution of the phase convection equation, and we can remove it from
the system. The resulting discrete UC equations are then defined by the residuals
\begin{equation}
  \begin{split}\label{eq:ALE}
    R_u(W) &= \rho\left(\frac{\partial U_i}{\partial t} + (U_j - \beta^h_j) \frac{\partial U_i}{\partial x_j} \right) - \frac{\partial}{\partial x_j} \Sigma_{ij} - f_i,
    \\
    R_p(W) &= \frac{\partial U_j}{\partial x_j}.
  \end{split}
\end{equation}

We thus choose the mesh velocity $\beta_h$ to be the discrete material
velocity $U$ in the structure part of the mesh (vertices touching
structure cells) and in the rest of the mesh we use mesh smoothing to
determine $\beta_h$ to maximize the mesh quality. Alternatively, one
may use local mesh modification operations (refinement, coarsening,
swapping) on the mesh to maintain the quality
\citep{Comp`ereRemacleJanssonEtAl2009}.

\subsection{Streamline--diffusion stabilization}

The standard FEM formulation is unstable.  We therefore consider a
weighted standard streamline--diffusion method of the form
$\inner{R(W)}{v + \delta R(v)} = 0$ for all $v \in \hat{V}_h$ (see
\citet{ErikssonEstepHansboEtAl1996}) with $\delta > 0$ a stabilization
parameter. We make further simplifications by only including necessary
stabilization terms and dropping terms not contributing to
stabilization. Although not fully consistent, this avoids unnecessary
smearing of shear layers. For the UC model, the stabilized method thus
looks like:
%%
\begin{align}
  \inner{R^u(W)}{v^u} &=
  \inner{\rho(\frac{\partial U_i}{\partial t} + U_j \frac{\partial U_i}{\partial x_j} ) - f_i}{v^u_i} +
  \inner{\Sigma_{ij}}{\frac{\partial}{\partial x_j} v^u_i} + SD^u(W, v^u) = 0, \\
  \inner{R^p(W)}{v^p} &= \inner{\frac{\partial U_j}{\partial x_j}}{v^p} + SD^p(W, v^p) = 0,
\end{align}
for all $v \in \hat{V}_h$, where
\begin{align}
  SD^u(W, v^u) &=
  \delta_1 \inner{U_j \frac{\partial U_i}{\partial x_j}}{U_j \frac{\partial v^u_i}{\partial x_j} } +
  \delta_2 \inner{\frac{\partial U_j}{\partial x_j}}{\frac{\partial v^u}{\partial x_j} }, \\
  SD^p(W, v^p) &= \delta_1 \inner{\frac{\partial P}{\partial x_i}}{\frac{\partial v^p}{\partial x_i}}.
\end{align}

%------------------------------------------------------------------------------
\section{Implementation}

We here present an overview of the design of Unicorn. The Unicorn
solver class \emp{UCSolver} ties together the technology in the
Unicorn library with other parts of FEniCS to expose an interface (see
listing \ref{code:UCSolver}) for simulating applications in continuum
mechanics. The main part of the solver implementation is the weak
forms for the G2 discretization of the UC model, together with forms
for the stress and residuals for the error estimation. Coefficients
from the application are connected to the form, and then time-stepping
is carried out by the class \emp{TimeDependentPDE}. Certain
coefficients, such as the $\delta$ stabilization coefficients are also
computed as part of the solver (not as forms). The solver computes one
iteration of the adaptive algorithm (primal solve, dual solve and mesh
refinement), where the adaptive loop is implemented by iteratively
running the solver for a sequence of meshes.

The \emp{UCSolver} implementation is parallelized for distributed
memory architectures using MPI, and we can show strong scaling for
hundreds of cores on several platforms (see
Figure~\ref{fig:hoffman-2:sp}). The entire adaptive algorithm is
parallel (including Rivara mesh refinement and \emph{a priori} predictive
load balancing). An example of a parallel adaptive simulation is shown
in Figure~\ref{fig:parcyl3D}. Fluid--structure interaction is not yet
enabled in parallel but this is work in progress.

\begin{figure}
  \centering
  \includegraphics[height=5.5cm]{chapters/hoffman-2/pdf/speedup_solve.pdf}
  \includegraphics[height=5.5cm]{chapters/hoffman-2/pdf/speedup_unrivara.pdf}
  \caption{\label{fig:hoffman-2:sp} Strong scaling results for mesh
    refinement and entire solver on several different architectures:
    \textit{Lindgren} (Cray XT6m), \textit{Hebb} (BlueGene/L) and
    \textit{Neolith} (regular Linux cluster with InfiniBand). The dashed
    line refers to ideal speedup}
\end{figure}

A compressible variant of the \emp{UCSolver} exists as the
\emp{CNSSolver} for adaptive G2 for compressible Euler flow. The
general method and algorithm is very close to that of the
\emp{UCSolver}, aside from the incompressibility. The long term goal
is a unification of the incompressible/compressible formulations as
well. We refer to \citet{Nazarov2009} for implementation details of
the compressible \emp{CNSSolver}. See Figure~\ref{fig:compr3D} for an
example plot of compressible flow around a sphere.

\begin{figure}
\begin{c++}
class UCSolver :
  public TimeDependentPDE, public MeshAdaptInterface
{
public:
  /// Constructor: give boundary conditions,
  /// coefficients
  UCSolver(Function& U, Function& U0,
           Function** bisect, Mesh& mesh,
           Array <BoundaryCondition*>& bc_mom,
           Array <BoundaryCondition*>& bc_con,
           Function** f, real T, real nu,
           real mu, real rho_f, real rho_s,
           real u_bar, TimeDependent& t,
           PDEData* pdedata);

  /// Prescribe mesh size for MeshAdaptInterface
  virtual void updateSizeField();

  /// Allocate/deallocate PDE data for dynamic mesh
  /// adaptivity
  virtual void allocateAndComputeData();
  virtual void deallocateData();

  /// Compute mesh vertex coordinates and velocity
  void computeX();
  void computeW();

  /// Compute density, pressure, stress
  void computeRho();
  void computeP();
  void computeStress();

  /// Compute initial theta
  void computeTheta0();

  /// From TimeDependentPDE: time-stepping control
  void shift();
  bool update(real t, bool end);
  void preparestep();
  void prepareiteration();

  /// Assemble time step residual (L) right-hand
  /// side of Newton
  void rhs(const Vector& x, Vector& dotx, real T);

  /// Compute initial value
  void u0(Vector& x);

  /// Save solution/output quantities
  void save(Function& U, real t);

  /// Compute least-squares stabilization parameters
  /// (delta)
  void computeStabilization(Mesh& mesh, Function& w,
                            real nu, real k, real t,
                            Vector& d1vector,
                            Vector& d2vector);

  /// Deform/move mesh
  void deform(Mesh& mesh, Function& W, Function& W0);

  /// Smooth/optimize quality of all or part of the
  /// mesh
  void smoothMesh(bool bAdaptive);
}
\end{c++}
\caption{C++ class interface for the Unicorn class \emp{UCSolver}.}
\label{code:UCSolver}
\end{figure}

\subsection{Unicorn classes/interfaces}

Key concepts are abstracted in the following classes/interfaces:
%%
\begin{description}
\item[\emp{TimeDependentPDE}: \ time-stepping]
\ \\
In each time-step a nonlinear algebraic system is solved by
fixed-point iteration.
\item[\emp{ErrorEstimate}: \ adaptive error control] \ \\ The adaptive
  algorithm is based on computing local {\em error indicators} of the
  form $\eta_K = \|h R(U)\|_T \|D Z\|_T$, where $Z$ is the so-called
  dual solution.

\item[\emp{SpaceTimeFunction}: \ space-time coefficient]
\ \\
Storage and evaluation of a space-time function/coefficient.
\item[\emp{SlipBC}: \ friction boundary condition] \ \\ Efficient
  computation of turbulent flow in Unicorn is based on modeling of
  turbulent boundary layers by a friction model, where the slip
  boundary condition $u \cdot n = 0$ is implemented strongly as part
  of the algebraic system.
\item[\emp{ElasticSmoother}: \ elastic mesh smoothing/optimization]
\ \\
Optimization of cell quality according to an elastic analogy.
\item[\emp{MeshAdaptInterface}: \ mesh adaptation interface]
\ \\
Abstraction of the interface to the MAdLib package for mesh adaptation
using local mesh operations.
\end{description}

\subsection{\emp{TimeDependentPDE}}

We consider general time-dependent equations of the type
$\frac{\partial}{\partial t} u + A(u) = 0$, where $A$ denotes a
possibly nonlinear differential operator in space. We want to define a
class (data structures and algorithms) abstracting the time-stepping
of the G2 method. The equation is given as input and the time-stepping
should be generated automatically. We do this for the \cgone{}\cgone{}
method by applying a simplified Newton's method. This is encapsulated
in a C++ class interface in
Figure~\ref{code:TimeDependentPDE} called \emp{TimeDependentPDE}.

\begin{figure}
\begin{c++}
/// Represent and solve time dependent PDE.
class TimeDependentPDE
{
  /// Public interface
public:
  TimeDependentPDE(
   // Computational mesh
   Mesh& mesh,
   // Bilinear form for Jacobian approx.
   Form& a,
   // Linear form for time-step residual
   Form& L,
   // List of boundary conditions
   Array <BoundaryCondition*>& bcs,
   // End time
   real T);

  /// Solve PDE
  virtual uint solve();

protected:
  /// Compute initial value
  virtual void u0(Vector& u);
  /// Called before each time step
  virtual void preparestep();
  /// Called before each fixed-point iteration
  virtual void prepareiteration();
  /// Return the bilinear form a
  Form& a();
  /// Return the linear form L
  Form& L();
  /// Return the mesh
  Mesh& mesh();
};
\end{c++}
\caption{C++ class interface for \emp{TimeDependentPDE}.}
\label{code:TimeDependentPDE}
\end{figure}

The skeleton of the time-stepping with fixed-point iteration is
implemented in listing \ref{code:time-stepping}.

\begin{figure}
\begin{c++}
void TimeDependentPDE::solve()
{
  // Time-stepping
  while (t < T)
  {
    U = U0;
    preparestep();
    step();
  }
}

void TimeDependentPDE::step()
{
  // Fixed-point iteration
  for(int iter = 0; iter < maxiter; iter++)
  {
    prepareiteration();
    step_residual = iter();

    if (step_residual < tol)
    {
      // Iteration converged
      break;
    }
  }
}

void TimeDependentPDE::iter()
{
  // Compute one fixed-point iteration
  assemble(J, a());
  assemble(b, L());
  for (uint i = 0; i < bc().size(); i++)
    bc()[i]->apply(J, b, a());
  solve(J, x, b);

  // Compute residual for the time-step/fixed-point
  // equation
  J.mult(x, residual);
  residual -= b;

  return residual.norm(linf);
}
\end{c++}
\label{code:time-stepping}
\caption{Skeleton implementation in Unicorn of time-stepping with
fixed-point iteration.}
\end{figure}

We use a block-diagonal quasi-Newton method, where we start by
formulating the full Newton method and then drop terms off the
diagonal blocks. We also use the constitutive law as an identity to
express $\Sigma$ in terms of $U$, allowing larger time steps than
would be possibly otherwise by iterating between $\Sigma$ and $U$.
See \citet{Jansson2009} for a discussion about the efficiency of the
fixed-point iteration and its implementation.

\subsection{\emp{ErrorEstimate}}

The duality-based adaptive error control algorithm requires the
following components:

\begin{description}
\item[Residual computation] We compute the mean-value in each cell of
  the residual $R(U)$ by an $L^2$-projection into the space of piecewise
  constants.
\item[Dual solution] We compute the solution of the dual problem using
  the same technology as the primal problem. The dual problem is
  solved backward in time, but using the time coordinate transform $s =
  T - t$ we can use the standard \emp{TimeDependentPDE} interface.
\item[Space-time function storage/evaluation] We compute error
  indicators while solving the dual problem as space-time integrals
  over cells: $\eta_T = \inner{R(U)}{\frac{\partial}{\partial x} Z}$, where
  we need to evaluate both the primal solution $U$ and the dual
  solution $Z$. In addition, $U$ is a coefficient in the dual
  equation. This requires storage and evaluation of a space-time
  function, which is encapsulated in the \emp{SpaceTimeFunction}
  class.
\item[Mesh adaptation] After the computation of the error indicators,
  we select the largest $p\%$ of the indicators for refinement. The
  refinement is then performed by recursive Rivara cell bisection.
  Alternatively, one may use MAdLib
  \citep{Comp`ereRemacleJanssonEtAl2009} for more general mesh
  adaptation based on edge split, collapse and swap operations.
\end{description}

Using these components, we can construct an adaptive algorithm. The
adaptive algorithm is encapsulated in the C++ class interface in
Figure~\ref{code:ErrorEstimate} which we call \emp{ErrorEstimate}.

\begin{figure}
\begin{c++}
/// Estimate error as local error indicators based
/// on duality
class ErrorEstimate
{
public:

  /// Constructor (give components of UC residual
  /// and dual solution)
  ErrorEstimate(Mesh& mesh,
		Form* Lres_1,
		Form* Lres_2,
		Form* Lres_3,
		Form* LDphi_1,
		Form* LDphi_2,
		Form* LDphi_3);

  // Compute error (norm estimate)
  void ComputeError(real& error);

  // Compute error indicator
  void ComputeErrorIndicator(real t, real k,
                             real T);

  // Compute largest indicators
  void ComputeLargestIndicators(
    std::vector<int>& cells,
    real percentage);

  // Refine based on indicators
  void AdaptiveRefinement(real percentage);
}
\end{c++}
\caption{C++ class interface for \emp{ErrorEstimate}.}
\label{code:ErrorEstimate}
\end{figure}

\subsection{\emp{SpaceTimeFunction}}

The error estimation algorithm requires, as part of solving the dual
problem, the evaluation of space-time coefficients appearing in the
definition of the dual problem. In particular, we must evaluate the
primal solution $U$ at time $t = T - t$.  This requires storage and
evaluation of a space-time function, which is encapsulated in the
\emp{SpaceTimeFunction} class (see listing
\ref{code:SpaceTimeFunction}).

The space-time functionality is implemented as a list of space
functions at regular sample times, where evaluation is piecewise
linear interpolation in time of the degrees of freedom.

\begin{figure}
\begin{c++}
/// Representation of space-time function (storage
/// and evaluation)
class SpaceTimeFunction
{
public:

  /// Create space-time function
  SpaceTimeFunction(Mesh& mesh, Function& Ut);

  /// Evaluate function at time t, giving result in
  /// Ut
  void eval(real t);

  // Add a space function at time t
  void addPoint(std::string Uname, real t);

  /// Return mesh associated with function
  Mesh& mesh();

  /// Return interpolant function
  Function& evaluant();
}
\end{c++}
\caption{C++ class interface for \emp{SpaceTimeFunction}.}
\label{code:SpaceTimeFunction}
\end{figure}

\subsection{\emp{SlipBC}}

For high Reynolds number problems such as car aerodynamics or airplane
flight, it is not possible to resolve the turbulent boundary
layer. One possibility is then to model turbulent boundary layers by a
friction model:
%%
\begin{align}
u \cdot n &= 0
\\
\beta u \cdot \tau_k + (\sigma n) \cdot \tau_k &= 0, k = 1, 2.
\end{align}
%%
We implement the normal component condition (slip) boundary condition
strongly. By ``strongly'' we here mean an implementation of the
boundary condition after assembling the left-hand side matrix and the
right-hand side vector in the algebraic system, whereas the tangential
components (friction) are implemented ``weakly'' by adding boundary
integrals in the variational formulation. The row of the matrix and
load vector corresponding to a degree of freedom is found and replaced
by a new row according to the boundary condition.

The idea is as follows: Initially, the test function $v$ is expressed
in the Cartesian standard basis $(e_1, e_2, e_3)$.  Now, the test
function is mapped locally to normal-tangent coordinates with the
basis $(n, \tau_1, \tau_2)$, where $n = (n_1, n_2, n_3)$ is the
normal, and $\tau_1 = (\tau_{11}, \tau_{12}, \tau_{13})$, $\tau_2 =
(\tau_{21}, \tau_{22}, \tau_{23})$ are tangents to each node on the
boundary. This allows us to let the normal direction be constrained
and the tangent directions be free:
\begin{equation}
     v = (v \cdot n)n + (v \cdot \tau_1) \tau_1 + (v \cdot \tau_2) \tau_2.
\end{equation}
For the matrix and vector this means that the rows corresponding to the
boundary need to be multiplied with $n,\tau_1,\tau_2$, respectively,
and then the normal component of the velocity should be set to zero.

This concept is encapsulated in the class \emp{SlipBC} which is a
subclass of \emp{dolfin::BoundaryCondition} for representing strong
boundary conditions. For more details about the implementation of slip
boundary conditions,we refer to \citet{Nazarov2009}.

\subsection{\emp{ElasticSmoother}}

\begin{figure}
\begin{center}
\begin{tabular}{cc}
\includegraphics[height=0.24\linewidth]{chapters/hoffman-2/pdf/force_smooth01.pdf} &
\includegraphics[height=0.24\linewidth]{chapters/hoffman-2/pdf/force_hybrid01.pdf}\\
\includegraphics[height=0.24\linewidth]{chapters/hoffman-2/pdf/force_smooth02.pdf} &
\includegraphics[height=0.24\linewidth]{chapters/hoffman-2/pdf/force_hybrid02.pdf}\\
\includegraphics[height=0.24\linewidth]{chapters/hoffman-2/pdf/force_smooth03.pdf} &
\includegraphics[height=0.24\linewidth]{chapters/hoffman-2/pdf/force_hybrid03.pdf}\\
(a) & (b)
\end{tabular}
\end{center}
\caption{Robustness test with (a) elastic smoothing and (b) mesh
adaptation. Note the badly shaped cells squeezed between the cube
and flag.}
\label{fig:flag_robustness}
\end{figure}

\begin{figure}
\begin{c++}
/// Optimize cell quality according to elastic
/// variant of UC model
class ElasticSmoother
{
public:

  ElasticSmoother(Mesh& mesh);

  /// Smooth smoothed_cells giving mesh velocity W
  /// over time step k with h0 the prescribed cell
  /// size
  void smooth(MeshFunction<bool>& smoothed_cells,
              MeshFunction<bool>& masked_cells,
              MeshFunction<real>& h0,
              Function& W, real k);

  /// Extract submesh (for smoothing only marked cells)
  static void
  submesh(Mesh& mesh, Mesh& sub,
	  MeshFunction<bool>& smoothed_cells,
	  MeshFunction<int>& old2new_vertex,
	  MeshFunction<int>& old2new_cell);

}
\end{c++}
\caption{C++ class interface for {\emp{ElasticSmoother}}.}
\label{code:ElasticSmoother}
\end{figure}

To maintain a discontinuous phase interface in the UC model, we define
the mesh velocity $\beta_h$ as the discrete velocity $U$ in the solid
phase (specifically on the interface). The mesh velocity in the fluid
can be chosen more arbitrarily, but has to satisfy mesh quality and
size criteria. We construct a cell quality optimization/smoothing
method based on a pure elastic variant of the UC. We define the
following requirements for the mesh velocity~$\beta_h$:
%%
\begin{enumerate}
\item $\beta_h = U$ in the solid phase part of the mesh.
\item Bounded mesh quality $Q$ defined by $$Q = \frac{d \| F
  \|_F^2}{\det(F)^{\frac{2}{d}}},$$ where $d$ is the spatial dimension, in
  the fluid part of the mesh. Preferably the mesh smoothing should
  improve $Q$ if possible.
\item Maintain mesh size $h(x)$ close to a desired $\hat{h}(x)$ given
  by \emph{a posteriori} error estimation in an adaptive algorithm.
\end{enumerate}
%%
Mesh smoothing is handled in Unicorn by an elastic model using the
constitutive law $\sigma = \mu(I - (FF^\top)^{-1})$ where we recall
$F$ as the deformation gradient. We use the update law:
$\frac{\partial}{\partial t} F^{-1} = -F^{-1} \nabla u$ where we thus
need an initial condition for $F$. We set the initial condition $F_0 =
\bar{F}$ where $\bar{F}$ is the deformation gradient with regard to a
scaled equilateral reference cell, representing the optimal shape with
quality~$Q = 1$.

Solving the elastic model can thus be seen as optimizing for the
highest global quality $Q$ in the mesh. We also introduce a weight on
the Young's modulus $\mu$ for cells with low quality, penalizing high
average, but low local quality over mediocre global quality. We refer
to the source code for more details.

Unicorn provides the \emp{ElasticSmoother} class (see listing
\ref{code:ElasticSmoother}, which can be used to smooth/optimize for
quality in all or part of the mesh.

We perform a robustness test of the elastic smoothing and the mesh
adaptivity shown in \ref{fig:flag_robustness} where we use the same
geometry as the turbulent 3D flag problem, but define a zero inflow
velocity and instead add a gravity body force to the flag to create a
very large deformation with the flag pointing straight down. Both the
elastic smoothing and the mesh adaptivity compute solutions, but as
expected, the elastic mesh smoothing eventually cannot control the
cell quality; there does not exist a mesh motion which can handle
large rigid body rotations while bounding the cell quality.

\subsection{\emp{MeshAdaptInterface}}

A critical component in the adaptive algorithm as described above is
{\em mesh adaptivity}, which we define as constructing a mesh
satisfying a given mesh size function~$h(x)$.

We start by presenting the Rivara recursive bisection algorithm
\citep{Rivara1992} as a basic choice for mesh adaptivity (currently
the only available choice for parallel mesh adaptivity), but which can
only refine and not coarsen. Then the more general MAdLib is
presented, which enables full mesh adaptation to the prescribed
$h(x)$ through local mesh operations: edge split, edge collapse and
edge swap.

\paragraph{Rivara recursive bisection}

The Rivara algorithm bisects (splits) the longest edge of a cell, thus
replacing the cell with two new cells, and uses recursive bisection to
eliminate non-conforming cells with hanging nodes.
%%
\begin{algorithm}
\caption{The Rivara recursive bisection algorithm}
\label{alg:rivara}
\begin{algorithmic}
\Procedure{bisect}{$T$}
\State Split longest edge $e$
\While{$T_i(e)$ is non-conforming}
\State BISECT($T_i$)
\EndWhile
\EndProcedure
\end{algorithmic}
\end{algorithm}
%%
The same algorithm holds in both 2D/3D (triangles/tetrahedra). In 2D,
it can be shown \citep{Rivara1992} that the algorithm terminates in a
finite number of steps, and that the minimum angle of the refined mesh
is at least half the minimum angle of the starting mesh. In practice,
the algorithm produces excellent quality refined meshes both in 2D and
3D.

\paragraph{Local mesh operations: MAdLib}

\begin{figure}
\begin{center}
\begin{tabular}{cc}
\centering
\includegraphics[height=3cm,width=6cm]{chapters/hoffman-2/pdf/swap.pdf} &
\hspace{0.3cm}
\includegraphics[height=3cm,width=6cm]{chapters/hoffman-2/pdf/swap_config1.pdf}
\end{tabular}
\end{center}
\caption{Edge swap operation: (a) initial cavity with swap edge
highlighted (b) possible configuration after the swap.}
\label{fig:op:eswap}
\end{figure}

MAdLib incorporates an algorithm and implementation of mesh adaptation
in which a small set of local mesh modification operators are defined
such as edge split, edge collapse and edge swap (see
Figure~\ref{fig:op:eswap} for an illustration of the edge swap
operator). A mesh adaptation algorithm is defined which uses this set
of local operators in a control loop to satisfy a prescribed size
field $h(x)$ and quality tolerance. Edge swapping is the key operator
for improving the quality of cells, for example around a vertex with a
large number of connected edges.

In the formulation of finite element methods, it is typically assumed
that the cell size of a computational mesh can be freely modified to
satisfy a desired size field $h(x)$ or to allow mesh motion. In
state-of-the-art finite element software implementations, this is
seldom the case \citep{BangerthHartmannKanschat2007, COMSOL2009}.

The mesh adaptation algorithm in MAdLib gives the freedom to adapt to
a specified size field using local mesh operations. The implementation
is published as free/open-source software.

Unicorn provides the \emp{MeshAdaptInterface} class (see listing
\ref{code:MeshAdaptInterface}), where one can subclass and implement
virtual functions to control the mesh adaptation using MAdLib.

\begin{figure}
\begin{c++}
/// Interface to MAdLib for mesh adaptation using
/// local operations Subclass and implement the
/// virtual functions
class MeshAdaptInterface
{
public:
  MeshAdaptInterface(Mesh *);

protected:
  /// Start mesh adaptation algorithm
  void adaptMesh();

  /// Give cell size field
  virtual void updateSizeField() = 0;

  /// Allocate and deallocate solver data
  virtual void deallocateData() = 0;
  virtual void allocateAndComputeData() = 0;

  /// Constrain entities not to be adapted
  void constrainExternalBoundaries();
  void constrainInternalBoundaries();

  /// Add functions to be automatically interpolated
  void addFunction(string name, Function** f);
  void clearFunctions();
};
\end{c++}
\caption{C++ class interface for \emp{MeshAdaptInterface}.}
\label{code:MeshAdaptInterface}
\end{figure}

%------------------------------------------------------------------------------
\section{Solving continuum mechanics problems}

In this section, we present some examples computed using Unicorn.  The
first example is a fluid--structure interaction problem without
adaptivity, where we cover modeling of geometry and subdomains,
coefficients, dynamic allocation of PDE data for mesh adaptivity and
specification of the main program (interface to running the
solver). Next, we present an example of solving a turbulent pure fluid
problem with adaptivity, where we cover modeling of data for the dual
problem, the adaptive loop, and specifying slip/friction boundary
conditions for modeling turbulent boundary layers.

\subsection{Fluid--structure interaction}

\editornote{What's the point of this section? There is no code and no plots?}

We here present an example of solving a fluid--structure continuum
mechanics problem, where the user specifies data for modeling the
problem. We divide the presentation into four parts:

\begin{description}
\item[Geometry and subdomains] \ \\ The user specifies possible
  geometrical parameters and defines subdomains. We note that for
  complex geometries the user may omit geometry information and
  specify subdomain markers as data files.
\item[Coefficients] \ \\ Known coefficients such as a force function
  and boundary conditions are declared.
\item[PDE data] \ \\ The user subclasses a \emp{PDEData} class and
  specifies how the PDE data is constructed and destroyed. This
  construction/destruction may happen during the simulation if the
  mesh is adapted.
\item[main program] \ \\ The user implements the main program and
  declares and passes data to to the solver.
\end{description}

\subsection{Adaptivity}

\editornote{Where is the solution?}

We continue with a use case for adaptive solution of a pure fluid
turbulent flow problem: flow around a 3D cylinder. The implementation
of the problem is very similar to the fluid--structure case (just with
pure fluid data), but with 3 important additions:
\begin{description}
\item[Dual problem] \ \\ To compute the error estimate required by the
  adaptive algorithm, we must solve a dual problem generated by the
  primal problem and an output quantity $\psi$. Since the dual problem
  is similar in form to the primal problem, we implement both as
  variants of the same solver.

In this case we are interested in computing drag, which gives $\psi$
as a boundary condition for the dual problem:

\begin{c++}
CylinderBoundary cb;
SubSystem xcomp(0);
Function minus_one(mesh, -1.0);

DirichletBC dual_bc0(minus_one, mesh, cb, xcomp);

Array <BoundaryCondition*> dual_bc_mom;
dual_bc_mom.push_back(&dual_bc0);
\end{c++}

\item[Adaptive loop] \ \\ We construct the program to compute one
  iteration of the adaptive loop: solve primal problem, solve dual
  problem, compute error estimate and check if tolerance is satisfied,
  compute adapted mesh. We can then run the adaptive loop simply by a
  loop which runs the program (here in Python which we also use to
  move data according to iteration number):
%%
\begin{python}
offset = 0
N = 20

for i in range(offset, N):
    dirname = ``iter_%2.2d'' % i
    mkdir(dirname)

    system(``./unicorn-cylinder > log'')
    for file in glob(``./*.vtu''):
    move(file, dirname)
    for file in glob(``./*.pvd''):
    move(file, dirname)
\end{python}

\item[Slip boundary condition] \ \\ For turbulent flow we model the
  boundary layer as a friction boundary condition. We specify the
  normal component as a string slip boundary condition used just as a
  regular Dirichlet boundary condition. The \emp{xcomp} variable
  denotes an offset for the first velocity component in a system (for
  compressible Euler the system is [density, velocity, energy], and we
  would thus give component 2 as offset).
%%
\begin{c++}
SlipBoundary sb;
SubSystem xcomp(0);

SlipBC slip_bc(mesh, sb, xcomp);

Array <BoundaryCondition*> primal_bc_mom;
primal_bc_mom.push_back(&slip_bc);
\end{c++}

\end{description}

\begin{figure}
\begin{c++}
#include <dolfin.h>
#include <unicorn/FSIPDE.h>

using namespace dolfin;
using namespace dolfin::unicorn;

real bmarg = 1.0e-3 + DOLFIN_EPS;

namespace Geo
{
  // Geometry details
  real box_L = 3.0;
  real box_H = 2.0;
  real box_W = 2.0;

  real xmin = 0.0; real xmax = box_L;
  real ymin = 0.0; real ymax = box_H;
  real zmin = 0.0; real zmax = box_W;
}

// Sub domain for inflow
class InflowBoundary3D : public SubDomain
{
public:
  bool inside(const real* p, bool on_boundary) const
  {
    return on_boundary && (p[0] < Geo::xmax - bmarg);
  }
};

// Sub domain for outflow
class OutflowBoundary3D : public SubDomain
{
public:
  bool inside(const real* p, bool on_boundary) const
  {
    return on_boundary && (p[0] > Geo::xmax - bmarg);
  }
};
\end{c++}
\caption{Part 1 of Unicorn solver FSI use case: geometry and subdomains.}
\end{figure}

\begin{figure}
\begin{c++}
// Force term
class ForceFunction : public Function
{
public:
  ForceFunction(Mesh& mesh, TimeDependent& td) : Function(mesh), td(td) {}
  void eval(real* values, const real* x) const
  {
    int d = cell().dim();

    for (int i = 0; i < d; i++)
    {
      values[i] = 0.0;
    }
  }

  TimeDependent& td;
};

// Boundary condition for momentum equation
class BC_Momentum_3D : public Function
{
public:
  BC_Momentum_3D(Mesh& mesh, TimeDependent& td) :
    Function(mesh), td(td) {}
  void eval(real* values, const real* x) const
  {
    int d = cell().dim();

    for (int i = 0; i < d; i++)
    {
      values[i] = 0.0;
    }
    if (x[0] < (Geo::xmin + bmarg))
      values[0] = 100.0;
  }

  TimeDependent& td;
};

// Initial condition for phase variable
class BisectionFunction : public Function
{
public:
  BisectionFunction(Mesh& mesh) : Function(mesh) {}
  void eval(real* values, const real* p) const
  {
    // NB: We specify the phase variable as
    // xml data so this function is not used

    bool condition = true;

    if (condition)
      values[0] = 0.0;
    else
      values[0] = 1.0;
  }
};
\end{c++}
\caption{Part 2 of Unicorn solver FSI use case: coefficients.}
\end{figure}

\begin{figure}
\begin{c++}
int main()
{
  Mesh mesh("flag.xml");

  real nu = 0.0;
  real nus = 0.5;
  real rhof = 1.0;
  real rhos = 1.0;

  real E = 1.0e6;

  real T = 0.2;

  dolfin::set("ODE number of samples", 500);

  Function U, U0;

  real u_bar = 100.0;

  FlagData pdedata;

  ICNSPDE pde(U, U0, &(pdedata.bisect), mesh,
	      pdedata.bc_mom, pdedata.bc_con,
	      &(pdedata.f), T, nu, E, nus, rhof, rhos,
	      u_bar, pdedata.td, &pdedata);

  // Compute solution
  pde.solve(U, U0);

  return 0;
}
\end{c++}
\caption{Part 4 of FSI use case: main program, passing data to solver.}
\end{figure}

\subsection{Unicorn-HPC installation and basic test}

\editornote{Where is the solution, the implementation and the problem definition?}

Unicorn-HPC is the high-performance computing branch of Unicorn,
showing strong linear scaling on massively parallel hardware as
described above.

To verify the correct installation and functionality of Unicorn-HPC,
follow the steps in the README file in the Unicorn-HPC distribution,
under ``Testing''. The test represents the turbulent flow past a cube
simulation described in Chapter~\ref{chap:hoffman-1}.

%------------------------------------------------------------------------------
\section{Acknowledgments}

We acknowledge contributions to Unicorn, both software development as
well as ideas and scientific support from: Mattias Aechtner, Peter
Brune, Zilan Ciftci, G\"aetan Compere, Claes Johnson, Ashraful Kadir,
Jeannette Sp\"uhler, Michael St\"ockli and Rodrigo Vilela de Abreu.
