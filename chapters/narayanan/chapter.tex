\def\bone{{\bf 1}}
\def\Bepsilon{\mbox{\boldmath$\epsilon$}}
\def\Bvarphi{\mbox{\boldmath$\varphi$}}
\def\bB{\mbox{\boldmath$ B$}}
\def\bC{\mbox{\boldmath$ C$}}
\def\bE{\mbox{\boldmath$ E$}}
\def\bF{\mbox{\boldmath$ F$}}
\def\bN{\mbox{\boldmath$ N$}}
\def\bP{\mbox{\boldmath$ P$}}
\def\bS{\mbox{\boldmath$ S$}}
\def\bT{\mbox{\boldmath$ T$}}
\def\bX{\mbox{\boldmath$ X$}}
\def\ba{\mbox{\boldmath$ a$}}
\def\bb{\mbox{\boldmath$ b$}}
\def\be{\mbox{\boldmath$ e$}}
\def\bg{\mbox{\boldmath$ g$}}
\def\br{\mbox{\boldmath$ r$}}
\def\bu{\mbox{\boldmath$ u$}}
\def\bv{\mbox{\boldmath$ v$}}
\def\bw{\mbox{\boldmath$ w$}}
\def\twist{{\tt cbc.twist}}

\fenicschapter{A computational framework for nonlinear elasticity}
{cbc.twist}
{Harish Narayanan}
{narayanan}

Nonlinear elasticity theory plays a fundamental role in modelling the
mechanical response of many polymeric and biological materials. Such
materials are capable of undergoing finite deformation, and their
material response is often characterised by complex, nonlinear
constitutive relationships. (See, for example, \cite{Holzapfel2000}
and \cite{TruesdellNoll1965} and the references within for several
examples.) Because of these difficulties, predicting the response of
arbitrary structures composed of such materials to arbitrary loads
requires numerical computation, usually based on the finite element
method. The steps involved in the construction of the required finite
element algorithms are classical and straightforward in principle, but
their application to non-trivial material models are typically tedious
and error-prone. Our recent work on an automated computational
framework for nonlinear elasticity, \twist, is an attempt to alleviate
this problem.

The focus of this chapter will be to describe the design and
implementation of \twist, as well as providing examples of its
use. The goal is to allow researchers to easily pose and solve
problems in nonlinear elasticity in a straightforward manner, so that
they may focus on higher-level modelling questions without being
hindered by specific implementation issues.

What follows is the proposed outline for the chapter.

The chapter begins with a summary of some key results from classical
nonlinear elasticity theory. This discussion is used to motivate the
design of \twist, which is a PyDOLFIN (\cite{LoggWells2010}) module
written in UFL syntax (\cite{AlnaesA.Logg2009}) that closely resembles
how the theory is written down on paper. In particular, we will see
how one can easily pose sophisticated material models purely at the
level of specifying a strain energy function. The discourse will then
turn to the primary equation of interest: the balance of linear
momentum of a body posed in the reference configuration. A finite
element scheme for this equation will then be presented, pointing out
how \twist{} leverages the automatic linearisation capabilities of UFL
to implement this scheme in a manner that is independent of the
specific material model. The time-stepping schemes that \twist{}
implements will also be discussed. With this in place, we turn to
increasingly complex examples to see how initial- boundary-value
problems in nonlinear elasticity can be posed and solved in \twist{}
using only a few lines of high-level code. The chapter concludes with
some remarks on how one can obtain \twist, along with ideas for its
extension.


\section{Brief overview of nonlinear elasticity theory as it relates
  to \twist}

The goal of this section is to present an overview of the mathematical
theory of nonlinear elasticity, which plays an important role in the
design of \twist. Readers interested in a more comprehensive treatment
of the subject are referred to, for example, the classical treatises
of \cite{TruesdellToupin1960} and \cite{TruesdellNoll1965}, or more
modern works such as \cite{Gurtin1981}, \cite{Ogden1997} and
\cite{Holzapfel2000}.

\subsection{Posing the question we aim to answer}

The theory begins by idealising the elastic body of interest as an
open subset of $\mathbb{R}^{2, 3}$ with a piecewise smooth
boundary. At a {\em reference} placement of the body, $\Omega_0$,
points in the body are identified by their reference positions, $\bX
\in \Omega_0$. The treatment presented in this chapter is posed in
terms of fields which are parametrised by reference positions. This is
commonly termed the {\em material} or {\em Lagrangian} description.

In its most basic terms, the {\em deformation} of the body over a time
$t \in [0, T]$ is a sufficiently smooth bijective map $\Bvarphi:
\overline{\Omega}_0 \times [0,T] \rightarrow \mathbb{R}^{2, 3}$, where
$\overline{\Omega}_0 :=\ \overline{\Omega_0\cup\partial\Omega_0}$ and
$\partial\Omega_0$ is the boundary of $\Omega_0$. The restrictions on
the map ensure that the motion it describes is physical (e.g.,
disallowing the interpenetration of matter or the formation of
cracks). From this, we can construct the {\em displacement field},

\begin{equation}
  \bu(\bX, t) = \Bvarphi(\bX, t) - \bX,
\end{equation}

\noindent which represents the displacement of a point in time
relative to its reference position.

With this brief background, we are ready to pose the fundamental
question that \twist{} is designed to answer: Given a body comprised
of a specified elastic material, what is the displacement of the body
when it is subjected to prescribed:

\begin{itemize}
\item {\em Body forces:} These include forces such as the self weight
  of a body, forces on ferromagnetic materials in magnetic fields,
  etc., which act everywhere in the volume of the body. They are
  denoted by the vector field $\bB(\bX, t)$.
\item {\em Traction forces:} This is the force measured per unit
  surface area acting on the {\em Neumann} boundary of the body,
  $\partial\Omega_{0_{\mathrm{N}}}$, and denoted by the vector field
  $\bT(\bX, t)$.
\item {\em Displacement boundary conditions:} These are displacement
  fields prescribed on the {\em Dirichlet} boundary of the body,
  $\partial\Omega_{0_{\mathrm{D}}}$.
\end{itemize}

\noindent It is assumed that $\partial\Omega_{0_{\mathrm{N}}}
\cap \partial\Omega_{0_{\mathrm{D}}} = \emptyset$ and
$\partial\Omega_{0_{\mathrm{N}}} \cup \partial\Omega_{0_{\mathrm{D}}}
= \partial\Omega_0$. These details are depicted in
Figure~\ref{fig:narayanan:continuumpotato}.

\begin{figure}[ht]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{chapters/narayanan/images%
      /pdf/continuumpotato}
    \label{fig:narayanan:continuumpotato}
  \end{center}
  \caption{An elastic body idealised as a continuum, subjected to body
    forces, $\bB$, surface tractions, $\bT$, and prescribed
    displacement boundary conditions.}
\end{figure}

\subsection{The basic equation we need to solve}

In order to determine the displacement of an elastic body subjected to
these specified loads and boundary conditions, we turn to a fundamental
law called the  {\em balance of linear momentum}.\footnote{We focus on
  the balance of linear momentum, because the other fundamental
  balance principles that materials must obey: the balance of mass
  (continuity equation), balance of angular momentum and balance of
  energy are each trivially satisfied in the Lagrangian description by
  elastic materials with suitably chosen stress responses.} This is a
law which is valid for all materials and must hold for all
time. \twist{} solves the Lagrangian form of this equation, which is
presented below in local form that is pertinent to numerical
implementation by the finite element method:

\begin{equation}
  \rho_{0} \frac{\partial^{2} \bu}{\partial t^{2}} = \mathrm{Div}(\bP)
  + \bB\; \mathrm{in}\; \Omega_0,
  \label{eq:narayanan:balance-of-momentum}
\end{equation}

\noindent where $\rho_{0}$ is the {\em reference density} of the body,
$\bP$ is the {\em first Piola--Kirchhoff stress tensor}, $\mathrm{Div}
(\cdot)$ is the divergence operator and $\bB$ is the body force per
unit volume. Along with \eqref{eq:narayanan:balance-of%
-momentum}, we have initial conditions $\bu(\bX, 0) = \bu_{0}(\bX)$
and $\frac{\partial\bu}{\partial t}(\bX, 0) = \bv_{0}(\bX)$ in
$\Omega_{0}$, and boundary conditions $\bu(\bX, t) = \bg(\bX, t)$ on
$\partial\Omega_{0_{\mathrm{D}}}$ and $\bP \bN = \bT$ on
$\partial\Omega_{0_{\mathrm{N}}}$. Here, $\bN$ is the outward normal
on the boundary.

\subsection{Accounting for different materials}

It is important to reiterate that
\eqref{eq:narayanan:balance-of-momentum} is valid for all
materials. In order to differentiate between different materials and
to characterise their specific mechanical responses, the theory turns
to {\em constitutive relationships}, which are models for describing
the real mechanical behaviour of matter. In the case of nonlinear
elastic (or {\em hyperelastic}) materials, this description is posed
in the form of a stress-strain relationship through an objective and
frame-indifferent Helmholtz free energy function called the {\em
strain energy function}, $\psi$. This is an energy defined per unit
reference volume and is solely a function of the local {\em strain
measure}. Comprehensive texts on the subject
(e.g. \cite{Holzapfel2000}) cover the motivations for defining
different forms of strain measures, but in this chapter we just look
at the definitions of some of the most common forms. In what follows,
$\mathrm{Grad}(\cdot)$ is the gradient operator, and
$\mathrm{Tr}(\cdot)$ and $\mathrm{Det}(\cdot)$ are the trace and
determinant of $\cdot$ respectively.

\begin{table}
\begin{tabular}{rl}
Infinitesimal strain tensor & $\Bepsilon = \frac{1}{2} 
  \left(\mathrm{Grad}(\bu) + \mathrm{Grad}(\bu)^{\mathrm{T}}\right)$\\
Deformation gradient &  $\bF = \bone + \mathrm{Grad}(\bu)$ \\
Right Cauchy--Green tensor & $\bC = \bF^{\mathrm{T}} \bF$\\
Green--Lagrange strain tensor & $\bE = \frac{1}{2} \left(\bC - \bone\right)$\\
Left Cauchy--Green tensor & $\bb = \bF \bF^{\mathrm{T}}$\\
Euler--Almansi strain tensor &  $\be = \frac{1}{2} \left(\bone -
    \bb^{-1}\right)$\\
Volumetric and isochoric\\ decomposition of $\bC$ &  $\bar{\bC} =
  J^{-\frac{2}{3}} \bC$, \quad $J = \mathrm{Det}(\bF)$\\
Principal invariants of $\bC$ &  $I_{1} =
  \mathrm{Tr}(\bC)$, $I_{2} = \frac{1}{2}\left(I_{1}^{2} -
    \mathrm{Tr}(\bC^{2})\right)$, $I_{3} = \mathrm{Det}(\bC)$\\
Principal stretches and directions &  $\bC = \sum_{A=1}^{3}
\lambda_{A}^{2} \bN^{A} \otimes \bN^{A}, \quad ||\bN^{A}|| = 1$\\
\caption{Definitions of some common strain measures.}
\end{tabular}
\label{tab:narayanan:straindefs}
\end{table}


\begin{figure}[ht]
\begin{python}
# Deformation gradient
def DeformationGradient(u):
    I = SecondOrderIdentity(u)
    return variable(I + Grad(u))

# Determinant of the deformation gradient
def Jacobian(u):
    F = DeformationGradient(u)
    return variable(det(F))

# Right Cauchy-Green tensor
def RightCauchyGreen(u):
    F = DeformationGradient(u)
    return variable(F.T*F)

# Green-Lagrange strain tensor
def GreenLagrangeStrain(u):
    I = SecondOrderIdentity(u)
    C = RightCauchyGreen(u)
    return variable(0.5*(C - I))

# Invariants of an arbitrary tensor, A
def Invariants(A):
    I1 = tr(A)
    I2 = 0.5*(tr(A)**2 - tr(A*A))
    I3 = det(A)
    return [I1, I2, I3]

# Isochoric part of the deformation gradient
def IsochoricDeformationGradient(u):
    F = DeformationGradient(u)
    J = Jacobian(u)
    return variable(J**(-1.0/3.0)*F)

# Isochoric part of the right Cauchy-Green tensor
def IsochoricRightCauchyGreen(u):
    C = RightCauchyGreen(u)
    J = Jacobian(u)
    return variable(J**(-2.0/3.0)*C)
\end{python}
\caption{Samples of how strain measures are implemented in \twist.}
\label{code:narayanan:kinematics.py}
\end{figure}

In \twist, each of the forms listed in
Table~\ref{tab:narayanan:straindefs} have been implemented in the
file {\tt kinematics.py} in {\tt UFL} notation that closely resemble
their definitions above. Figure~\ref{code:narayanan:kinematics.py} presents a 
section of this file. Notice that it is straightforward to introduce
other custom measures as required.

%\footnote{\textcolor[named]{BrickRed}{TODO:
%Talk about principal stretch/direction definition, complete with
%citation here. Reference: Oliver K. Smith: Eigenvalues of a symmetric
%3 × 3 matrix. Commun. ACM 4(4): 168 (1961)}}

The stress response of isotropic hyperelastic materials (the class of
materials \twist{} restricts its attention to) can be derived from the
scalar-valued strain energy function. In particular, the tensor known
as the {\em second Piola--Kirchhoff stress tensor} is defined using the
following {\em constitutive relationship}:

\begin{equation}
\bS = \bF^{-1} \frac{\partial \psi(\bF)}{\partial \bF}
\end{equation}

\noindent The second Piola--Kirchhoff stress tensor is related to the
first Piola--Kirchhoff stress tensor introduced earlier through the
relation, $\bP = \bF \bS$.

As already mentioned, the strain energy function can be posed in
equivalent forms in terms of other strain measures. (Again, the reader
is directed to classical texts to motivate this.) In order to then
arrive at the second Piola--Kirchhoff stress tensor, we turn to the
chain rule of differentiation. For example,

\begin{equation}
\begin{split}
  \bS & = 2 \frac{\partial \psi(\bC)}{\partial \bC} = \frac{\partial
    \psi(\bE)}{\partial \bE}\\
      & = 2\left[\left(\frac{\partial \psi (I_{1}, I_{2},
            I_{3})}{\partial I_{1}} + I_{1} \frac{\partial \psi (I_{1}, I_{2},
            I_{3})}{\partial I_{2}} \right) \bone - \frac{\partial \psi (I_{1},
          I_{2}, I_{3})}{\partial I_{2}} \bC + I_{3} \frac{\partial \psi (I_{1},
          I_{2}, I_{3})}{\partial I_{3}} \bC^{-1} \right]\\
      & = \sum_{A = 1}^{3}
      \frac{1}{\lambda_{A}} \frac{\partial \psi(\lambda_{1},
        \lambda_{2}, \lambda_{3})}{\partial
        \lambda_{A}} \bN^{A}\otimes\bN^{A} = \ldots
\end{split}
\label{eq:narayanan:secondpk}
\end{equation}

Using definitions such as the ones explicitly provided in
\eqref{eq:narayanan:secondpk}, \twist{} computes the second
Piola--Kirchhoff stress tensor from the strain energy function by
suitably differentiating it with respect to the appropriate strain
measure. This allows the user to easily specify material models in
terms of each of the strain measures introduced in
Table~\ref{tab:narayanan:straindefs}. The base class for all
material models, {\tt MaterialModel}, encapsulates this
functionality. The relevant method of this class is provided in
Figure~\ref{code:narayanan:material_model_base.py}. The implementation
relies heavily on the UFL {\tt diff()} operator.

\begin{figure}[ht]
\begin{python}
def SecondPiolaKirchhoffStress(self, u):
  
  ...

  if kinematic_measure == "InfinitesimalStrain":
    epsilon = self.epsilon
    S = diff(psi, epsilon)
  elif kinematic_measure == "RightCauchyGreen":
    C = self.C
    S = 2*diff(psi, C)            
  elif kinematic_measure == "GreenLagrangeStrain":
    E = self.E
    S = diff(psi, E)
  elif kinematic_measure == "CauchyGreenInvariants":
    I = self.I; C = self.C
    I1 = self.I1; I2 = self.I2; I3 = self.I3
    gamma1 = diff(psi, I1) + I1*diff(psi, I2)
    gamma2 = -diff(psi, I2)
    gamma3 = I3*diff(psi, I3)
    S = 2*(gamma1*I + gamma2*C + gamma3*inv(C))

  ...
  return S
\end{python}
\label{code:narayanan:material_model_base.py}
\caption{Partial listing of the method that suitably computes the
  second Piola--Kirchhoff stress tensor based on the strain measure.}
\end{figure}

\newpage

The generality of the material model base class allows for the (almost
trivial) specification of a large set of models. To see this in
practise, let us consider two popular material models,

\begin{itemize}

\item the {\em St.~Venant--Kirchhoff} model:
$\psi_{\mathrm{SVK}} = \frac{\lambda}{2}\mathrm{Tr}(\bE)^{2} +
\mu\mathrm{Tr}(\bE^{2})$, and
\item the two term {\em Mooney--Rivlin} model:
$\psi_{\mathrm{MR}} = c_{1} (I_{1} - 3) + c_{2} (I_{2} -
3)$,
\end{itemize}

\noindent and see how they can be specified in \twist. The relevant blocks of
code are shown in Figures~\ref{code:narayanan:svk} and
\ref{code:narayanan:mr}.

\begin{figure}[ht]
\begin{python}
class StVenantKirchhoff(MaterialModel)

  def model_info(self):
    self.num_parameters = 2
    self.kinematic_measure = "GreenLagrangeStrain"

  def strain_energy(self, parameters):
    E = self.E
    [mu, lmbda] = parameters
    return lmbda/2*(tr(E)**2) + mu*tr(E*E)
\end{python}
\caption{Definition the strain energy function for a
  St.~Venant--Kirchhoff material.}
\label{code:narayanan:svk}
\end{figure}

\begin{figure}[!ht]
\begin{python}
class MooneyRivlin(MaterialModel)

  def model_info(self):
    self.num_parameters = 2
    self.kinematic_measure = "CauchyGreenInvariants"

  def strain_energy(self, parameters):
    I1 = self.I1
    I2 = self.I2
    [C1, C2] = parameters
    return C1*(I1 - 3) + C2*(I2 - 3)
\end{python}
\caption{Definition the strain energy function for a two term
  Mooney--Rivlin material.}
\label{code:narayanan:mr}
\end{figure}

\noindent Clearly, the code simply contains the strain energy function
in classical notation, along with some metadata clarifying the number
of material parameters and the strain measure the model relies on. The
file {\tt material\_models.py} contains several other material models,
including {\em linear elasticity, neo Hookean, Isihara, Biderman,} and
{\em Gent--Thomas} that come pre-implemented in \twist. (Refer to the
article by \cite{MarckmannVerron2006} comparing several hyperelastic
models for rubber-like materials for their definitions.) But the
salient point to note here is that it is straightforward to introduce
other additional models, and this is a significant feature of \twist.

\section{Numerical methods and further implementation details}

In the preceding section, we saw the functionality that \twist{}
provided to easily specify material models to suitably characterise
different materials of interest. In this section, we return to the
general form of the balance of linear momentum and look at details of
a finite element formulation and implementation for this equation. For
further details on the treatment that follows, the interested reader
is directed to \cite{SimoHughes1998}.

\subsection{The finite element formulation of the balance of linear
  momentum}

By taking the dot product of
\eqref{eq:narayanan:balance-of-momentum} with a test function 
$\bv \in \hat{\mathrm{V}}$ and integrating over the reference domain
and time, we have

\begin{equation}
 \int_{t} \int_{\Omega_{0}} \rho_{0} \frac{\partial^{2}
    \bu}{\partial t^{2}} \cdot \bv \dx \dt\;
  = \int_{t}\int_{\Omega_{0}} \mathrm{Div}(\bP) \cdot \bv \dx \dt\;
  + \int_{t} \int_{\Omega_{0}} \bB \cdot \bv \dx \dt.
\end{equation}

\noindent Noting that the traction vector $\bT = \bP \bN$ on
$\partial\Omega_{0_{\mathrm{N}}}$ ($\bN$ being the outward normal
on the boundary) and that by definition
$\bv|_{\partial\Omega_{0_{\mathrm{D}}}} = 0$, we apply the divergence
theorem to arrive at the following weak form of the balance of linear
momentum:

\noindent Find $\bu \in
\mathrm{V}$, such that $\forall\; \bv \in \hat{\mathrm{V}}$:
\begin{equation}
  \int_{t} \int_{\Omega_{0}} \rho_{0} \frac{\partial^{2} \bu}{\partial
t^{2}} \cdot \bv \dx \dt\; + \int_{t} \int_{\Omega_{0}}
\bP:\mathrm{Grad}(\bv) \dx \dt\; = \int_{t} \int_{\Omega_{0}} \bB
\cdot \bv \dx \dt\; + \int_{t} \int_{\partial\Omega_{0_{\mathrm{N}}}}
\bT \cdot \bv \ds \dt,
\label{eq:narayanan:weakform}
\end{equation}

\noindent with initial conditions $\bu(\bX, 0) = \bu_{0}(\bX)$ and
$\frac{\partial\bu}{\partial t}(\bX, 0) = \bv_{0}(\bX)$ in
$\Omega_{0}$, and boundary conditions $\bu(\bX, t) = \bg(\bX, t)$ on
$\partial\Omega_{0_{\mathrm{D}}}$.

The finite element formulation implemented in \twist{} follows the
Galerkin approximation of the above weak
form~\eqref{eq:narayanan:weakform}, by looking for solutions in a finite
solution space  $\mathrm{V}^{h} \subset \mathrm{V}$ and allowing for
test functions in a finite approximation of the test space
$\hat{\mathrm{V}^{h}} \subset \hat{\mathrm{V}}$.\footnote{We now
  note an inherent advantage in choosing the Lagrangian description in
  formulating the theory. The fact that the integrals in
  \eqref{eq:narayanan:weakform}, along with the various fields
  and differential operators, are defined over the fixed domain
  $\Omega_{0}$ means that one need not be concerned with the
  complexity associated with calculations on a moving computational
  domain when implementing this formulation.}

\subsection{Implementation of the static form}

We consider first the static weak form (dropping the time derivative
term) of the balance of linear momentum which reads

\begin{equation}
  \int_{\Omega_{0}} \bP:\mathrm{Grad}(\bv) \dx - \int_{\Omega_{0}} \bB
  \cdot \bv \dx -  \int_{\partial\Omega_{0_{\mathrm{N}}}} \bT \cdot
  \bv \ds = 0.
\label{eq:narayanan:staticweakform}
\end{equation}

\noindent Since \twist{} provides the necessary functionality to
easily compute the first Piola--Kirchhoff stress tensor, $\bP$, given a
displacement field, $\bu$, for arbitrary material models, 
\eqref{eq:narayanan:staticweakform} is just a nonlinear functional in
terms of $\bu$. The automatic
differentiation capabilities of UFL make this nonlinear form
straightforward to implement, as evidenced by the code listing in
Figure~\ref{code:narayanan:staticmomentumsolver}.

This listing provides the relevant section of the static balance of
linear momentum solver class, {\tt StaticMomentumBalanceSolver}. The
class draws information about the problem (mesh, loading, boundary
conditions and form of the stress equation derived from the material
model) from the user-specified problem class,\footnote{Details of how
the user can specify problem details are covered in the following
section containing examples of \twist{} usage.} and solves the
nonlinear momentum balance equation using a Newton solver.

\begin{figure}[ht]
\begin{python}
# Get the problem mesh
mesh = problem.mesh()

# Define the function space
vector = VectorFunctionSpace(mesh, "CG", 1)

# Test and trial functions
v = TestFunction(vector)
u = Function(vector)
du = TrialFunction(vector)

# Get forces and boundary conditions
B = problem.body_force()
PN = problem.surface_traction()
bcu = problem.boundary_conditions()

# First Piola-Kirchhoff stress tensor based on
# the material model
P = problem.first_pk_stress(u)

# The variational form corresponding to static
# hyperelasticity
L = inner(P, Grad(v))*dx - inner(B, v)*dx - inner(PN, v)*ds
a = derivative(L, u, du)

# Setup and solve problem
equation = VariationalProblem(a, L, bcu,
                              nonlinear = True)
equation.solve(u)
\end{python}
\caption{The relevant section of the class {\tt
    StaticMomentumBalanceSolver}, the solver for the static balance of
  linear momentum.}
\label{code:narayanan:staticmomentumsolver}
\end{figure}

\subsection{Time-stepping algorithms}

\twist{} implements two time integration algorithms to solve the weak
form of the fully dynamic balance of linear momentum
\eqref{eq:narayanan:weakform}. The first of these is the
so-called cG(1) method (\cite{ErikssonEstepHansboEtAl1996}). In order
to derive this method, \eqref{eq:narayanan:weakform}, which is
a second order differential equation in time, is rewritten as a system
of first order equations. We do this by introducing an additional
velocity variable, $\bw = \frac{\partial \bu}{\partial t}$. Thus, the
weak form now reads:

\noindent Find ($\bu, \bw) \in \mathrm{V}$, such that $\forall\; (\bv,
\br) \in \hat{\mathrm{V}}$:

\begin{equation}
\begin{split}
  \int_{t} \int_{\Omega_{0}} \rho_{0} \frac{\partial \bw}{\partial t}
\cdot \bv \dx \dt\; + \int_{t} \int_{\Omega_{0}}
\bP:\mathrm{Grad}(\bv) \dx \dt\; &= \int_{t} \int_{\Omega_{0}} \bB
\cdot \bv \dx \dt\; + \int_{t} \int_{\partial\Omega_{0_{\mathrm{N}}}}
\bT \cdot \bv \ds \dt, \; \mathrm{and}\\ \int_{t} \int_{\Omega_{0}}
\frac{\partial \bu}{\partial t} \cdot \br \dx \dt\; &= \int_{t}
\int_{\Omega_{0}} \bw \cdot \br \dx \dt.
\end{split}
\label{eq:narayanan:cg1weakform}
\end{equation}

\noindent with initial conditions $\bu(\bX, 0) = \bu_{0}(\bX)$ and
$w(\bX, 0) = \bv_{0}(\bX)$ in $\Omega_{0}$, and boundary conditions
$\bu(\bX, t) = \bg(\bX, t)$ on $\partial\Omega_{0_{\mathrm{D}}}$.

We now assume that the finite element approximation space
$\mathrm{V}^{h}$ is CG(1) (continuous and piecewise linear in time),
and $\hat{\mathrm{V}^{h}}$ is DG(0) (discontinuous and piecewise
constant in time). With these assumptions, we arrive at the following
scheme:

\begin{equation}
\begin{split}
  \int_{\Omega_{0}} \rho_{0} \frac{\left(\bw_{n+1} - \bw_{n}\right)}{\Delta t} \cdot \bv \dx\;
  + \int_{\Omega_{0}} \bP(\bu_{\mathrm{mid}}):\mathrm{Grad}(\bv) \dx\;
  &=  \int_{\Omega_{0}} \bB \cdot \bv \dx\;
  +  \int_{\partial\Omega_{0_{\mathrm{N}}}} \bT \cdot \bv \ds,
  \; \mathrm{and}\\
    \int_{\Omega_{0}} \frac{\left(\bu_{n+1} - \bu_{n}\right)}{\Delta t} \cdot \br \dx\;
  &=  \int_{\Omega_{0}} \bw_{\mathrm{mid}} \cdot \br \dx,
\end{split}
\label{eq:narayanan:cg1weakformapprox}
\end{equation}

\noindent where $(\cdot)_{n}$ and $(\cdot)_{n+1}$ are the values of
a quantity at the current and subsequent time-step, respectively, and
$(\cdot)_{\mathrm{mid}} = \frac{(\cdot)_{n+1} +
  (\cdot)_{n+1}}{2}$.  A section of the CG(1) linear momentum balance
solver class is presented in Figure~\ref{code:narayanan:cg1}. The code
closely mirrors the scheme defined in
\eqref{eq:narayanan:cg1weakformapprox}, and results in a mixed system
that is solved for using a Newton scheme.

\begin{figure}[ht]
\begin{python}
class CG1MomentumBalanceSolver(CBCSolver):
      
    # Define function spaces
    vector = VectorFunctionSpace(mesh, "CG", 1)
    mixed_element = MixedFunctionSpace([vector,
                                        vector])
    V = TestFunction(mixed_element)
    dU = TrialFunction(mixed_element)
    U = Function(mixed_element)
    U0 = Function(mixed_element)
      
    # Get initial conditions, boundary conditions
    # and body forces
    ...
      
    # Functions
    v, r = split(V)
    u, w = split(U)
    u0, w0 = split(U0)
      
    # Evaluate displacements and velocities at
    # mid points
    u_mid = 0.5*(u0 + u)
    w_mid = 0.5*(w0 + w)

    # Get reference density
    rho0 = problem.reference_density()

    # Piola-Kirchhoff stress tensor based on the
    # material model
    P = problem.first_pk_stress(u_mid)

    # The variational form corresponding to
    # dynamic hyperelasticity
    L = rho0*inner(w - w0, v)*dx \
        + dt*inner(P, grad(v))*dx \
        - dt*inner(B, v)*dx\
        + inner(u - u0, r)*dx \
        - dt*inner(w_mid, r)*dx

    # Add contributions to the form from the
    # Neumann boundary conditions
    ...

    a = derivative(L, U, dU)
\end{python}
\caption{Relevant portion of the dynamic balance of linear momentum
  balance solver using the CG(1) time-stepping scheme.}
\label{code:narayanan:cg1}
\end{figure}

The CG(1) scheme defined in \eqref{eq:narayanan:cg1weak%
formapprox} is straightforward to derive and implement, and it is
second order accurate and energy conserving.\footnote{This is
  demonstrated in Figure~\ref{fig:narayanan:energies} as part of the
  second example calculation.}  But it should also be noted that the mixed
system that results from the formulation is computationally expensive
and memory intensive as the number of variables being solved for have
doubled.

\twist{} also provides a standard implementation of a time-stepping
algorithm that is commonly used in the computational mechanics
community: the Hilber--Hughes--Taylor (HHT) method
(\cite{HilberHughesTaylor1977}). The stability and dissipative
properties of this method in the case of linear problems have been
thoroughly discussed in \cite{Hughes1987}. In particular, the method
contains three parameters $\alpha$, $\beta$ and $\gamma$ which control
the accuracy, stability and numerical dissipation of the
scheme. The default values for these parameters chosen in \twist{}
($\alpha = 1$, $\beta = \frac{1}{4}$ and $\gamma = \frac{1}{2}$)
ensure that the method is second order accurate, stable for linear
problems and introduces no numerical dissipation.

The method is briefly sketched below in terms of the strong form of
the problem. For further details about the scheme itself, or its
implementation in \twist, the interested reader is directed to the
previously mentioned papers, and the {\tt MomentumBalanceSolver} class
in the file {\tt solution\_algorithms.py}.

Given initial conditions $\bu(\bX, 0) = \bu_{0}(\bX)$ and
$\frac{\partial\bu}{\partial t}(\bX, 0) = \bv_{0}(\bX)$, we can
compute the initial acceleration,

\begin{equation}
\ba_{0} = \frac{1}{\rho_{0}} (\mathrm{Div}(\bP) + \bB),
\end{equation}

\noindent providing the complete initial state ($\bu_{0}, \bv_{0},
\ba_{0}$) of the body. The HHT formulae advance the solution in time
as follows:

\begin{equation}
\begin{split}
\bu_{n+1} & = \bu_{n} + \Delta t \bv_{n} + \Delta t^{2} \left[
  \left(\frac{1}{2} - \beta \right) \ba_{n} + \beta \ba_{n+1}
\right]\\
\bv_{n+1} & = \bv_{n} + \Delta t \left[ (1-\gamma) \ba_{n} + \gamma
  \ba_{n+1} \right]\\
\bu_{n+\alpha} & = (1 - \alpha) \bu_{n} + \alpha \bu_{n+1}\\
\bv_{n+\alpha} & = (1 - \alpha) \bv_{n} + \alpha \bv_{n+1}
\end{split}
\label{eq:narayanan:hhtdefs}
\end{equation}

\noindent Then, we insert the definitions in
\eqref{eq:narayanan:hhtdefs} into the following form of the
balance of linear momentum and solve for the only unknown variable,
the acceleration at the next step, $\ba_{n+1}$:

\begin{equation}
  \rho_{0} \ba_{n+1} = \mathrm{Div}(P(\bu_{n+\alpha})) + B(t_{n+\alpha})
  \label{eq:narayanan:newaccn}
\end{equation}

\noindent The acceleration solution to
\eqref{eq:narayanan:newaccn} is then used in the
definitions~\eqref{eq:narayanan:hhtdefs} to update to new displacement
and velocity values, and the problem is stepped through time.

We close this subsection on time-stepping algorithms with one usage
detail pertaining to \twist. By default, when solving a dynamics
problem, \twist{} assumes the user wants to use the HHT method. In case
one wants to override this behaviour, they can do so by returning {\tt
  "CG(1)"} in the {\tt time\_stepping()} method while specifying the
problem. Figure~\ref{code:narayanan:dynamicrelease} is an example
showing this.

\section{Examples of \twist{} usage}

The algorithms discussed thus far serve primarily to explain the
computational framework's inner working, and are not at the level at
which the user usually interacts with \twist{} (unless they are
interested in extending it). In practise, the functionality of \twist{}
is exposed to the user through two primary problem definition classes:
{\tt StaticHyperelasticity} and {\tt Hyperelasticity}. These classes
reside in {\tt problem\_definitions.py}, and contain numerous methods
for defining aspects of the nonlinear elasticity problem. As their
names suggest, these are respectively used to describe static or
dynamic problems in nonlinear elasticity.

Over the course of the following examples, we will see how various
problems can be defined in \twist{} by suitably deriving from these
problem classes and overloading relevant methods.\footnote{The
examples presented in this chapter, along with a few others, reside in
the {\tt demos/twist/} folder in \twist's source repository. They can
be run by navigating to this folder and typing {\tt python
demo\_name.py} on the command line.} We will also see some results
from these calculations. The information defined in the problem
classes are internally transferred to the solvers described earlier to
actually solve the problem.

\subsection{The static twisting of a hyperelastic cube}

\begin{figure}[ht]
  \begin{center}
    \includegraphics{chapters/narayanan/images/png/twistedcube.png}
  \end{center}
  \caption{A hyperelastic cube twisted by 60 degrees.}
    \label{fig:narayanan:twistedcube}
\end{figure}

The first problem we are interested in is the twisting of a unit
hyperelastic cube (1~m$^3$). The cube is assumed to be made out of a
St.~Venant--Kirchhoff material with Lam\'e's parameters $\mu =
3.8461$~N/m$^2$ and a spatially varying $\lambda = 5.8 x_{1} + 5.7 (1
- x_{1})$~N/m$^2$. Here, $x_{1}$ is the first coordinate of the
reference position, $\bX$.\footnote{The numerical parameters in this
chapter have been arbitrarily chosen for illustration of the
framework's use. They do not necessarily correspond to a real
material.} In order to twist the cube, the face $x_{1} = 0$ is held
fixed and the opposite face $x_{1} = 1$ is rotated 60 degrees using
the Dirichlet condition defined in
Figure~\ref{code:narayanan:statictwist}.

Before getting to the actual specification of the problem in code, we
need to import \twist's functionality.

\begin{figure}[ht]
\begin{python}
from cbc.twist import *
\end{python}
\caption{\twist{} first needs to be imported to access the
  functionality that it offers.}
\end{figure}

\noindent The problem is completely specified by defining relevant
methods in the user-created class {\tt Twist} (see
Figure~\ref{code:narayanan:statictwist}), which derives from the base
class {\tt StaticHyperelasticity}. \twist{} only requires relevant
methods to be provided, and for the current problem, this includes the
computational domain, Dirichlet boundary conditions and material
model. The methods are fairly self-explanatory, but the following
points are to be noted. Firstly, \twist{} supports spatially-varying
material parameters. Secondly, Dirichlet boundary conditions are posed
in two parts: the conditions themselves, and the corresponding
boundaries along which they act.

\begin{figure}[ht]
\begin{python}
class Twist(StaticHyperelasticity):

    def mesh(self):
        n = 8
        return UnitCube(n, n, n)

    def dirichlet_conditions(self):
        clamp = Expression(("0.0", "0.0", "0.0"))
        twist = Expression(("0.0",
        "y0 + (x[1]-y0)*cos(theta) - (x[2]-z0)*sin(theta) - x[1]",
        "z0 + (x[1]-y0)*sin(theta) + (x[2]-z0)*cos(theta) - x[2]"))
        twist.y0 = 0.5
        twist.z0 = 0.5
        twist.theta = pi/3
        return [clamp, twist]

    def dirichlet_boundaries(self):
        return ["x[0] == 0.0", "x[0] == 1.0"]

    def material_model(self):
        mu    = 3.8461
        lmbda = Expression("x[0]*5.8+(1-x[0])*5.7")

        material = StVenantKirchhoff([mu, lmbda])
        return material

    def __str__(self):
        return "A cube twisted by 60 degrees"
\end{python}
\caption{Problem definition: The static twisting of a hyperelastic
  cube.}
\label{code:narayanan:statictwist}
\end{figure}

In order to solve this problem, an instance of the {\tt Twist} class
is created and its {\tt solve()} method is called (see
Figure~\ref{code:narayanan:solveproblem}). This triggers a Newton
solve which exhibits quadratic convergence (see
Table~\ref{tab:narayanan:residualnorms}) and results in the
displacement field shown in
Figure~\ref{fig:narayanan:twistedcube}.

\begin{figure}[ht]
\begin{python}
twist = Twist()
u = twist.solve()
\end{python}
\caption{Solving the posed problem.}
\label{code:narayanan:solveproblem}
\end{figure}

\begin{table}
  \centering
  \begin{tabular}{|c|c|}
    \hline Iteration & Relative Residual Norm \\
    \hline
    1 & 5.835e-01\\
    2 & 1.535e-01\\
    3 & 3.640e-02\\
    4 & 1.004e-02\\
    5 & 1.117e-03\\
    6 & 1.996e-05\\
    7 & 9.935e-09\\
    8 & 3.844e-15\\
    \hline
  \end{tabular}
  \caption{Quadratic convergence of the Newton method used to solve
    the hyperelasticity problem. It is interesting to note that this
    convergence is obtained even though the 60 degree twist condition
    was imposed in a single step.}
  \label{tab:narayanan:residualnorms}
\end{table}

\subsection{The dynamic release of a twisted cube}

In this problem, we release a unit cube (1~m$^3$) that has previously
been twisted. The initial twist was precomputed in a separate
calculation involving a traction force on the top surface and the
resulting displacement field was stored in the file {\tt
twisty.txt}. The release calculation loads this solution as the
initial displacement. It fixes the cube (made of a
St.~Venant--Kirchhoff material with Lam\'e's parameters $\mu =
3.8461$~N/m$^2$ and $\lambda = 5.76$~N/m$^2$) on the bottom surface,
and tracks the motion of the cube over 2~s.

The problem is specified in the user-created class {\tt Release},
which derives from {\tt Hyperelasticity}. This example is similar to
the previous one, except that since it is a dynamic calculation, it also
provides initial conditions, a reference density and information about
time-stepping. Again, the methods listed in
Figure~\ref{code:narayanan:dynamicrelease} are straightforward, and
the only additional point to note is that \twist{} provides some
convenience utilities to simplify the specification of the
problem. For example, one can load initial conditions directly from
files, and it allows for the specification of boundaries purely as
conditional strings.

\begin{figure}[ht]
\begin{python}
class Release(Hyperelasticity):

    def mesh(self):
        n = 8
        return UnitCube(n, n, n)

    def end_time(self):
        return 2.0

    def time_step(self):
        return 2.e-3

    def time_stepping(self):
        return "CG(1)"

    def reference_density(self):
        return 1.0

    def initial_conditions(self):
        u0 = "twisty.txt"
        v0 = Expression(("0.0", "0.0", "0.0"))
        return u0, v0

    def dirichlet_values(self):
        return [(0, 0, 0)]

    def dirichlet_boundaries(self):
        return ["x[0] == 0.0"]

    def material_model(self):
        mu    = 3.8461
        lmbda = 5.76
        material = StVenantKirchhoff([mu, lmbda])
        return material

    def __str__(self):
        return "A pretwisted cube being released"
\end{python}
\caption{Problem definition: The dynamic release of a twisted cube.}
\label{code:narayanan:dynamicrelease}
\end{figure}

When {\tt Release} is instantiated and its {\tt solve()} method is
called, we see the relaxation of the pre-twisted cube. After initial
unwinding of the twist, the body proceeds to twist in the opposite
direction due to inertia. This process repeats itself, and snapshots
of the displacement over the first 0.5~s are shown in
Figure~\ref{fig:narayanan:releasedcube}. Figure~\ref{fig:narayanan:energies}
highlights the energy conservation of the CG(1) numerical scheme used
to time-step this problem by totalling the kinetic energy and
potential energy of the body over the course of the
calculation. \twist{} provides this information through the methods
{\tt kinetic\_energy(v)} and {\tt potential\_energy(u)}, where {\tt v}
and {\tt u} are velocity and displacement fields respectively.

\begin{figure}[ht]
  \begin{center}
    \subfigure[$t = 0.0$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/release_000.png}
    }
    \subfigure[$t = 0.1$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/release_100.png}
      }
    \subfigure[$t = 0.2$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/release_200.png}
    }
    \subfigure[$t = 0.3$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/release_300.png}
    }
    \subfigure[$t = 0.4$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/release_400.png}
      }
    \subfigure[$t = 0.5$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/release_500.png}
    }
    \caption{Relaxation and subsequent re-twisting of a released cube
      over the first 0.5~s of the calculation.}
  \end{center}
  \label{fig:narayanan:releasedcube}
\end{figure}
 
\begin{figure}[ht]
  \begin{center}
    \includegraphics[scale=10]{chapters/narayanan/images/pdf/energies.pdf}
  \end{center}
  \caption{Over the course of the computation, the energy in the body
    is converted between potential and kinetic energy, but the total
    remains constant.}
    \label{fig:narayanan:energies}
\end{figure}

\subsection{A hyperelastic dolphin tumbling through a ``flow''}

In this final example, we aim to crudely simulate the motion of a
dolphin under a flow field. The dolphin is assumed to be made out of a
Mooney--Rivlin material ($c_{1} = 6.169$~N/m$^2$, $c_{2} =
10.15$~N/m$^2$), and the flow field is simply modelled by a uniform
traction force $\bT = (0.05, 0)$~N acting everywhere on the surface of
the dolphin, pushing it to the right.

This example is constructed to exhibit some additional features of
\twist. For one, \twist{} is capable of performing dynamic calculations
under entirely Neumann boundary conditions. In addition, this
calculation points out that the framework can seamlessly handle
problems in two dimensions as well.

The problem is specified in the user-created class {\tt FishyFlow}
derived from {\tt Hyperelasticity}. There is nothing new to note in
the code listing for this problem (Figure~\ref{code:narayanan:%
fishyflow}), other than the fact that we now specify Neumann boundary
conditions. The specification listing is not very long because
\twist{} assumes meaningful default values for unspecified
information.

\begin{figure}[ht]
\begin{python}
class FishyFlow(Hyperelasticity):

    def mesh(self):
        mesh = Mesh("dolphin.xml.gz")
        return mesh

    def end_time(self):
        return 10.0

    def time_step(self):
        return 0.1

    def neumann_conditions(self):
        flow_push = Expression(("force", "0.0"))
        flow_push.force = 0.05
        return [flow_push]

    def neumann_boundaries(self):
        everywhere = "on_boundary"
        return [everywhere]

    def material_model(self):

        material = MooneyRivlin([6.169, 10.15])
        return material
\end{python}
\caption{Problem definition: A hyperelastic dolphin being pushed to
  the right.}
\label{code:narayanan:fishyflow}
\end{figure}

To demonstrate one final piece of functionality of \twist, we don't
solve the problem in the same manner as we did the first two
examples. i.e., we do not instantiate an object of class {\tt
  FishyFlow} and call its {\tt solve()} method. Instead, we set up our
own time loop and manually step through time using the {\tt step()}
method. This is shown in Figure~\ref{code:narayanan:manualstep}.

\begin{figure}[ht]
\begin{python}
problem = FishyFlow()

dt = problem.time_step()
T = problem.end_time()

t = dt
while t <= T:
    problem.step(dt)
    problem.update()
    t = t + dt
\end{python}
\caption{Stepping through time in an external time loop. {\tt step()}
  steps the problem forward by one time step, and {\tt update()}
  updates the values of all time-dependent variables to the current time.}
\label{code:narayanan:manualstep}
\end{figure}

The advantage of solving the problem in this manner is that, now, one
has more control over calculations in \twist{}. For example, rather
than just fixing a traction force on the surface of the dolphin to
mimic the effect of flow field, one can instead solve at each time
step an actual flow field and use it to correctly drive the solid
mechanics. This functionality of \twist{} is used in a following
chapter on adaptive methods for fluid-structure interaction
(\cite{chap:selim}). In that work, the fluid-structure problem is
solved using a staggered approach with the solid mechanics equation
being solved by \twist. An external time loop similar to the one in
Figure~\ref{code:narayanan:manualstep} is set up to individually step
through the fluid problem, the solid problem and a mesh equation; a
process which is iterated until convergence is reached at each time
step. This process involves the systematic transfer of relevant
information (such as fluid loading) from other problems to \twist.

But returning to our current example,
Figure~\ref{fig:narayanan:tumblingdolphin} shows time snapshots of the
motion of the dolphin over the course of the computation. Notice that
the fish deforms elastically as it tumbles toward the right.

\begin{figure}[ht]
  \begin{center}
    \subfigure[$t = 0.0$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_000.png}
    }
    \subfigure[$t = 0.125$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_001.png}
      }
    \subfigure[$t = 0.250$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_002.png}
    }
    \subfigure[$t = 0.375$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_003.png}
    }
    \subfigure[$t = 0.500$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_004.png}
      }
    \subfigure[$t = 0.625$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_005.png}
    }
    \subfigure[$t = 0.750$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_006.png}
    }
    \subfigure[$t = 0.875$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_007.png}
      }
    \subfigure[$t = 1.000$ s]{
      \includegraphics[width=0.3\textwidth]{chapters/narayanan/images/png/dolphin_008.png}
    }
    \caption{The motion of a hyperelastic dolphin being forced to the
      right. Careful observation of the tail fin shows deformation of
      the dolphin in addition to its overall motion toward the right.}
  \end{center}
  \label{fig:narayanan:tumblingdolphin}
\end{figure}

\section{Conclusion}

This chapter presented an overview of \twist, an automated
computational framework for nonlinear elasticity. Beginning with
elements of classical nonlinear elasticity theory to motivate its
design, the discourse took a closer look at the algorithms underlying
\twist's implementation. The chapter concluded with some examples,
offering a tutorial-like description of how the framework can be used
in practise to solve problems.

The discussion aimed to highlight a central feature of \twist: the
ease with which different material models can be defined and
used. This feature makes \twist{} immediately applicable to a number
of real-world problems in engineering, especially those pertaining to
polymer and biological tissue mechanics.

\twist{} is a collaboratively developed open source project (released
under the GNU GPL) that is freely available from its source repository
at {\tt https://launchpad.net/cbc.solve/}. Its only dependency is a
working FEniCS installation. \twist{} is released with the goal that
it will allow users to easily solve problems in nonlinear elasticity
as part of answering specific questions through computational
modelling. Everyone is encouraged to fetch and try it. Users are also
encouraged to modify the code to better suit their own purposes, and
contribute changes that they think are useful to the community. Along
these lines, some possible ideas for extending the framework include:

\begin{itemize}
\item Implementing other specific material models
\item Allowing for bodies composed of multiple materials
\item Support for anisotropic materials
\item Support for viscoelastic materials
\item Goal-oriented adaptivity
\end{itemize}

\noindent Contributions toward these (or other useful) extensions are
welcome.