// Copyright (C) 2010 Anders Logg.
// Licensed under the GNU LGPL Version 2.1.

#include <iostream>
#include <dolfin.h>
#include <ufc.h>
#include "my_form.h"

typedef unsigned int uint;

// A simple matrix class
class Matrix
{
public:

  // Constructor
  Matrix() : M(0), N(0), values(0) {}

  // Destructor
  ~Matrix()
  {
    delete [] values;
  }

  // Initialize matrix
  void init(uint M, uint N)
  {
    this->M = M;
    this->N = N;
    values = new double[M * N];

    for (uint k = 0; k < M * N; k++)
      values[k] = 0.0;
  }

  // Element access
  double& operator() (uint i, uint j)
  {
    return values[i*N + j];
  }

  // Matrix data
  uint M, N;
  double* values;

};

void assemble(Matrix& A, ufc::form& form, dolfin::Mesh& mesh)
{
  // Get dimensions
  const uint D = mesh.topology().dim();
  const uint d = mesh.geometry().dim();

  // Initialize UFC mesh data structure
  ufc::mesh ufc_mesh;
  ufc_mesh.topological_dimension = D;
  ufc_mesh.geometric_dimension = d;
  ufc_mesh.num_entities = new uint[D + 1];
  for (uint i = 0; i <= D; i++)
    ufc_mesh.num_entities[i] = 0;
  ufc_mesh.num_entities[0] = mesh.num_vertices();
  ufc_mesh.num_entities[D] = mesh.num_cells();

  // Initialize UFC cell data structure, assuming that the
  // cell is a simplex and only vertices are used for dofs
  ufc::cell ufc_cell;
  switch (D)
  {
  case 1:
    ufc_cell.cell_shape = ufc::interval;
    break;
  case 2:
    ufc_cell.cell_shape = ufc::triangle;
    break;
  default:
    ufc_cell.cell_shape = ufc::tetrahedron;
    break;
  }
  ufc_cell.topological_dimension = D;
  ufc_cell.geometric_dimension = d;
  ufc_cell.entity_indices = new uint * [D + 1];
  for (uint i = 0; i <= D; i++)
    ufc_cell.entity_indices[i] = 0;
  uint vertices_per_cell = D + 1;
  ufc_cell.entity_indices[0] = new uint[vertices_per_cell];
  ufc_cell.entity_indices[D] = new uint[1];
  ufc_cell.coordinates = new double * [vertices_per_cell];
  for (uint i = 0; i <= D; i++)
    ufc_cell.coordinates[i] = new double[d];

  // Create cell integrals, assuming there is only one
  ufc::cell_integral* cell_integral = form.create_cell_integral(0);

  // Create dof maps for rows and columns
  ufc::dof_map* dof_map_0 = form.create_dof_map(0);
  ufc::dof_map* dof_map_1 = form.create_dof_map(1);

  // Initialize dof maps
  dof_map_0->init_mesh(ufc_mesh);
  dof_map_1->init_mesh(ufc_mesh);

  // Omitting code for dof map initialization on cells, which is not
  // needed for code generated by FFC but which is generally required

  // Get local and global dimensions
  uint m = dof_map_0->max_local_dimension();
  uint n = dof_map_1->max_local_dimension();
  uint M = dof_map_0->global_dimension();
  uint N = dof_map_1->global_dimension();

  // Initialize array of local-to-global maps
  uint* dofs_0 = new uint[m];
  uint* dofs_1 = new uint[n];

  // Initialize array of values for the cell matrix
  double* A_T = new double[m * n];

  // Initialize global matrix
  A.init(M, N);

  // Iterate over the cells of the mesh
  for (dolfin::CellIterator cell(mesh); !cell.end(); ++cell)
  {
    // Update UFC cell data structure for current cell
    ufc_cell.entity_indices[D][0] = cell->index();
    for (dolfin::VertexIterator vertex(*cell); !vertex.end(); ++vertex)
    {
      ufc_cell.entity_indices[0][vertex.pos()] = vertex->index();
      for (uint i = 0; i < d; i++)
        ufc_cell.coordinates[vertex.pos()][i] = vertex->x(i);
    }

    // Compute local-to-global map for degrees of freedom
    dof_map_0->tabulate_dofs(dofs_0, ufc_mesh, ufc_cell);
    dof_map_1->tabulate_dofs(dofs_1, ufc_mesh, ufc_cell);

    // Compute the cell matrix A_T
    cell_integral->tabulate_tensor(A_T, 0, ufc_cell);

    // Add entries to global matrix
    for (uint i = 0; i < m; i++)
      for (uint j = 0; j < m; j++)
        A(dofs_0[i], dofs_1[j]) += A_T[i*n + j];
  }

  // Omitting code for deleting allocated arrays
}

int main()
{
  Matrix A;
  my_form form;
  dolfin::UnitSquare mesh(2, 2);

  // Assemble
  assemble(A, form, mesh);

  // Display matrix
  for (uint i = 0; i < A.M; i++)
  {
    for (uint j = 0; j < A.N; j++)
      std::cout << A(i, j) << " ";
    std::cout << std::endl;
  }
}
